<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>遊戲選購導覽系統</title>
<style>
  :root{
    --bg:#f6f7fb;
    --panel:#ffffff;
    --text:#111827;
    --muted:#6b7280;
    --line:#e5e7eb;

    --primary:#2563eb;
    --primary2:#1d4ed8;
    --success:#16a34a;
    --warn:#f59e0b;
    --danger:#ef4444;

    --chip:#eef2ff;
    --shadow:0 10px 30px rgba(17,24,39,.08);
    --radius:14px;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Noto Sans TC", sans-serif;
    background:var(--bg);
    color:var(--text);
  }
  .layout{
    display:grid;
    grid-template-columns: 320px 1fr;
    min-height:100vh;
  }
  /* Sidebar */
  .sidebar{
    border-right:1px solid var(--line);
    background:#ffffff;
    padding:18px 14px;
    position:sticky;
    top:0;
    height:100vh;
    overflow:auto;
  }
  .brand{
    display:flex;
    gap:10px;
    align-items:center;
    padding:10px 10px 14px 10px;
  }
  .logo{
    width:34px;height:34px;border-radius:10px;
    background:linear-gradient(135deg, #2563eb, #22c55e);
  }
  .brand h1{
    font-size:16px;margin:0;
  }
  .brand p{ margin:2px 0 0 0; font-size:12px; color:var(--muted); }

  .stepList{ display:flex; flex-direction:column; gap:10px; padding:8px; }
  .stepBtn{
    width:100%;
    border:1px solid var(--line);
    background:var(--panel);
    border-radius:12px;
    padding:12px 12px;
    cursor:pointer;
    display:flex;
    justify-content:space-between;
    align-items:center;
    transition:.15s;
    text-align:left;
  }
  .stepBtn:hover{ transform:translateY(-1px); box-shadow:0 8px 18px rgba(17,24,39,.08); }
  .stepBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; box-shadow:none; }
  .stepTitle{
    display:flex; flex-direction:column; gap:3px;
  }
  .stepTitle b{ font-size:13px; }
  .stepTitle span{ font-size:12px; color:var(--muted); }
  .badge{
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background:#fafafa;
    color:var(--muted);
    white-space:nowrap;
  }
  .badge.active{ background:var(--chip); color:var(--primary2); border-color:#c7d2fe; }
  .badge.done{ background:#ecfdf5; color:var(--success); border-color:#bbf7d0; }

  /* Main */
  .main{ padding:18px; }
  .grid{
    display:grid;
    grid-template-columns: 1.25fr .75fr;
    gap:16px;
    align-items:start;
  }
  .card{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:16px;
  }
  .card h2{ margin:0 0 10px 0; font-size:16px; }
  .muted{ color:var(--muted); font-size:13px; line-height:1.6; }

  .row{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
  input[type=range]{ width:100%; }
  .valuePill{
    display:inline-block;
    padding:4px 10px;
    border-radius:999px;
    background:#f3f4f6;
    border:1px solid var(--line);
    font-size:12px;
    color:var(--text);
  }

  .controls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:12px;
  }
  .btn{
    border:none;
    border-radius:12px;
    padding:10px 12px;
    font-weight:600;
    cursor:pointer;
  }
  .btn.primary{ background:var(--primary); color:white; }
  .btn.primary:hover{ background:var(--primary2); }
  .btn.ghost{ background:#f3f4f6; color:var(--text); border:1px solid var(--line); }
  .btn.ghost:hover{ background:#eaeef5; }
  .btn[disabled]{ opacity:.5; cursor:not-allowed; }

  .statusLine{
    display:flex;
    gap:10px;
    align-items:center;
    margin-top:10px;
    padding-top:10px;
    border-top:1px dashed var(--line);
  }
  .dot{
    width:10px;height:10px;border-radius:999px;
    background:var(--warn);
  }
  .dot.ready{ background:var(--warn); }
  .dot.done{ background:var(--success); }
  .dot.err{ background:var(--danger); }

  /* 展示輸出 */
  .resultBox{
    margin-top:12px;
    border:1px dashed var(--line);
    border-radius:12px;
    padding:14px;
    background:#fbfbfd;
  }
  .kpis{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .kpi{
    border:1px solid var(--line);
    background:#fff;
    border-radius:12px;
    padding:10px 12px;
    min-width:140px;
  }
  .kpi .t{ font-size:12px; color:var(--muted); }
  .kpi .v{ font-size:16px; font-weight:800; margin-top:3px; }
  .list{
    margin:10px 0 0 18px;
    color:var(--muted);
    font-size:13px;
    line-height:1.7;
  }

  .algoBox ul{ margin:8px 0 0 18px; color:var(--muted); font-size:13px; line-height:1.7; }
  .kpi2{
    display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;
  }
  .chip{
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    background:var(--chip);
    border:1px solid #c7d2fe;
    color:var(--primary2);
  }
  .divider{
    margin:14px 0;
    border:none;
    border-top:1px solid var(--line);
  }
</style>
</head>

<body>
<div class="layout">

  <!-- 左側流程 -->
  <aside class="sidebar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>智慧遊戲選購 導覽系統</h1>
        <p>一步一步展示多種演算法</p>
      </div>
    </div>

    <div class="stepList">
      <button class="stepBtn" id="btnStep1" onclick="goStep(1)">
        <div class="stepTitle">
          <b>Step 1｜KNN</b>
          <span>找相似玩家</span>
        </div>
        <span class="badge active" id="badge1">進行中</span>
      </button>

      <button class="stepBtn" id="btnStep2" onclick="goStep(2)" disabled>
        <div class="stepTitle">
          <b>Step 2｜Hash Table</b>
          <span>合併候選遊戲</span>
        </div>
        <span class="badge" id="badge2">鎖定</span>
      </button>

      <button class="stepBtn" id="btnStep3" onclick="goStep(3)" disabled>
        <div class="stepTitle">
          <b>Step 3｜Binary Search</b>
          <span>時間上限篩選</span>
        </div>
        <span class="badge" id="badge3">鎖定</span>
      </button>

      <button class="stepBtn" id="btnStep4" onclick="goStep(4)" disabled>
        <div class="stepTitle">
          <b>Step 4｜Union-Find</b>
          <span>版本去重</span>
        </div>
        <span class="badge" id="badge4">鎖定</span>
      </button>

      <button class="stepBtn" id="btnStep5" onclick="goStep(5)" disabled>
        <div class="stepTitle">
          <b>Step 5｜Greedy + DP</b>
          <span>最佳組合</span>
        </div>
        <span class="badge" id="badge5">鎖定</span>
      </button>

      <button class="stepBtn" id="btnStep6" onclick="goStep(6)" disabled>
        <div class="stepTitle">
          <b>Step 6｜Max Flow（展示）</b>
          <span>類型平衡</span>
        </div>
        <span class="badge" id="badge6">鎖定</span>
      </button>
    </div>
  </aside>

  <!-- 右側主畫面 -->
  <main class="main">
    <div class="grid">

      <!-- 互動與結果 -->
      <section class="card">
        <h2 id="stepTitle">Step 1｜KNN：找相似玩家</h2>
        <p class="muted" id="stepSubtitle">
          調整你的偏好，系統會找出最相似的玩家，接著用他們的收藏庫作為推薦來源。
        </p>

        <!--  使用者選擇（你截圖消失的那塊，已加回來） -->
        <div class="resultBox" style="border-style:solid; border-color:var(--line); background:#fff;">
          <b>使用者選擇</b>
          <div class="row" style="margin-top:10px;">
            <div>
              <label>動作（Action） <span class="valuePill" id="va">6</span></label>
              <input type="range" id="p_action" min="0" max="10" value="5">
            </div>
            <div>
              <label>敘事（Narrative） <span class="valuePill" id="vn">7</span></label>
              <input type="range" id="p_narrative" min="0" max="10" value="5">
            </div>
            <div>
              <label>解謎（Puzzle） <span class="valuePill" id="vp">5</span></label>
              <input type="range" id="p_puzzle" min="0" max="10" value="5">
            </div>
            <div>
              <label>文字（Text） <span class="valuePill" id="vt">4</span></label>
              <input type="range" id="p_text" min="0" max="10" value="5">
            </div>
          </div>

          <div style="margin-top:10px;">
            <label>本週可用遊玩時間（小時） <span class="valuePill" id="timeLabel">20</span></label>
            <input type="range" id="timeLimit" min="3" max="40" value="20">
          </div>
        </div>

        <div class="controls">
          <!--  目標1：必須「執行 → 確定 → 下一步」 -->
          <button class="btn primary" id="runBtn" onclick="runCurrentStep()">執行本步驟</button>
          <button class="btn ghost" id="confirmBtn" onclick="confirmStep()" disabled>確定（鎖定結果）</button>
          <button class="btn primary" id="nextBtn" onclick="nextStep()" disabled>下一步 →</button>
          <button class="btn ghost" onclick="resetAll()">重設流程</button>
        </div>

        <div class="statusLine">
          <div class="dot ready" id="statusDot"></div>
          <div class="muted" id="statusText">請先「執行本步驟」，再按「確定」進入下一步。</div>
        </div>

        <!--  展示版輸出（不再是 raw JSON） -->
        <div class="resultBox" id="resultBox">
          資料載入中…（若一直卡住，請確認 games.json / players.json 與 index.html 同層，且以 GitHub Pages 開啟）
        </div>
      </section>

      <!-- 演算法說明 + 每步結論 -->
      <aside class="card algoBox">
        <h2>演算法說明</h2>
        <div class="muted" id="algoName">KNN（K-Nearest Neighbors）</div>

        <div class="kpi2" id="algoChips">
          <span class="chip">以距離衡量相似</span>
          <span class="chip">非參數式</span>
          <span class="chip">常用於推薦</span>
        </div>

        <ul id="algoBullets">
          <li>把你的偏好當作向量</li>
          <li>計算你與每位玩家的距離</li>
          <li>取距離最小的 K 位作為相似玩家</li>
        </ul>

        <hr class="divider"/>

        <h2 style="margin-bottom:8px;">每一步結論</h2>

        <div class="muted"><b>本步結論（最新）</b></div>
        <div class="muted" id="stepConclusionNow">尚未執行</div>

        <div class="muted" style="margin-top:10px;"><b>流程結論（累積）</b></div>
        <ul id="conclusionList" style="margin:8px 0 0 18px; color:var(--muted); font-size:13px; line-height:1.7;">
          <li>尚未開始</li>
        </ul>
      </aside>

    </div>
  </main>
</div>

<script>
/* =========================================================
    你所有目標是否完成（在程式內用行為保證）
   1) 一步一步：run → confirm → next（next 必須等 confirm）
   2) 顏色可讀：亮色卡片、清楚層次（CSS 已調整）
   3) 右側欄：演算法說明 + 每步結論（本步 + 累積）
   4) 使用者選擇區：已加回來，不會消失
   5) GitHub Pages：fetch 用 ./games.json ./players.json，避免子資料夾 404
   6) 修正你截圖的錯誤：切步會清空展示區，不會 Step1 顯示 Step3 的文字
========================================================= */

let games = [];
let players = [];

let currentStep = 1;
const stepDone = {1:false,2:false,3:false,4:false,5:false,6:false};
let stepHasRun = false;

let conclusionHistory = [];
let lastStepResult = null;

// 流程中間結果（真的有跑，不是假的）
let neighbors = [];
let candidateGameIds = [];
let timeFiltered = [];
let uniqueGames = [];
let bestSet = [];

const labelZh = { action:"動作", narrative:"敘事", puzzle:"解謎", text:"文字" };
function tagToZh(tag){ return labelZh[tag] ?? tag; }

function $(id){ return document.getElementById(id); }

function setStatus(type, text){
  const dot = $("statusDot");
  dot.className = "dot " + (type === "done" ? "done" : type === "err" ? "err" : "ready");
  $("statusText").textContent = text;
}

function syncSliderLabels(){
  $("va").textContent = $("p_action").value;
  $("vn").textContent = $("p_narrative").value;
  $("vp").textContent = $("p_puzzle").value;
  $("vt").textContent = $("p_text").value;
  $("timeLabel").textContent = $("timeLimit").value;
}
["p_action","p_narrative","p_puzzle","p_text","timeLimit"].forEach(id=>{
  $(id).addEventListener("input", () => {
    syncSliderLabels();
    invalidateCurrentStepBecauseInputChanged();
  });
});

syncSliderLabels();

function getUser(){
  return {
    action:+$("p_action").value,
    narrative:+$("p_narrative").value,
    puzzle:+$("p_puzzle").value,
    text:+$("p_text").value,
    timeLimit:+$("timeLimit").value
  };
}

function setResultHTML(html){
  $("resultBox").innerHTML = html;
}

function invalidateCurrentStepBecauseInputChanged(){
  // 只有在某些步驟，滑桿變動才會影響結果
  const affects =
    (currentStep === 1) || // KNN 受偏好影響
    (currentStep === 3) || // Binary Search 受時間影響
    (currentStep === 5);   // DP 受時間影響（你分數也可能依時間/候選變動）

  if(!affects) return;

  // 如果本步已經執行過，改參數就視為結果作廢
  if(stepHasRun || stepDone[currentStep] === false){
    stepHasRun = false;
    $("confirmBtn").disabled = true;
    $("nextBtn").disabled = true;

    setStatus("ready","參數已變更：請重新「執行本步驟」以更新結果。");
    // 也可以選擇清空結果，避免誤會
    // clearResultForStep();
  }
}

  
/* ===== 每步演算法說明（右側） ===== */
const algoInfo = {
  1: {
    title: "Step 1｜KNN：找相似玩家",
    subtitle: "調整你的偏好，系統找出最相似的玩家（最近鄰）作為推薦依據。",
    name: "KNN（K-Nearest Neighbors）",
    chips: ["以距離衡量相似", "非參數式", "常用於推薦/分類"],
    bullets: [
      "把你當作偏好向量",
      "計算你與每位玩家的距離（越小越像）",
      "取前 K 名相似玩家"
    ]
  },
  2: {
    title: "Step 2｜Hash Table：挖候選遊戲",
    subtitle: "把相似玩家的收藏庫合併成候選池，利用雜湊結構快速去重。",
    name: "Hash Table（雜湊表）",
    chips: ["平均 O(1) 查找", "快速去重/合併", "常用於索引"],
    bullets: [
      "把相似玩家的 library 合併",
      "用 Set（雜湊）快速判斷重複",
      "得到候選遊戲池"
    ]
  },
  3: {
    title: "Step 3｜Binary Search：時間上限篩選",
    subtitle: "先排序遊玩時間，再用二元搜尋找到可行範圍（玩得完的遊戲）。",
    name: "Binary Search（二元搜尋）",
    chips: ["O(log n)", "需排序", "找門檻/範圍很快"],
    bullets: [
      "候選遊戲依遊玩時間排序",
      "二元搜尋找到 <= 上限 的最後位置",
      "留下可玩清單"
    ]
  },
  4: {
    title: "Step 4｜Union-Find：版本去重",
    subtitle: "同款不同版本合併（以 groupId 模擬集合合併），避免推薦重複。",
    name: "Union-Find（聯合查找）",
    chips: ["快速合併集合", "避免重複", "資料清洗常用"],
    bullets: [
      "把同 groupId 視為同一款",
      "每組只保留一個代表",
      "避免推薦清單刷到同款不同版"
    ]
  },
  5: {
    title: "Step 5｜Greedy + DP：最佳組合",
    subtitle: "先用 Greedy 取高分候選，再用 DP 在時間上限下找總分最高組合。",
    name: "Greedy + Dynamic Programming（背包）",
    chips: ["先快後準", "0/1 背包", "全局最佳"],
    bullets: [
      "Greedy：先抓 Top-N 進候選",
      "DP：以時間為容量、符合度為價值",
      "輸出玩得完且最符合的組合"
    ]
  },
  6: {
    title: "Step 6｜Max Flow：類型平衡（展示）",
    subtitle: "最後一步強調多樣性：避免推薦全偏某類型（此處以配額平衡展示）。",
    name: "Max Flow（最大流｜展示）",
    chips: ["資源分配", "配額限制", "平衡多樣性"],
    bullets: [
      "把類型當成有容量的資源（配額）",
      "每款遊戲最多選一次",
      "讓清單更平均（展示版）"
    ]
  }
};

function renderAlgo(step){
  const info = algoInfo[step];
  $("stepTitle").textContent = info.title;
  $("stepSubtitle").textContent = info.subtitle;
  $("algoName").textContent = info.name;
  $("algoChips").innerHTML = info.chips.map(c=>`<span class="chip">${c}</span>`).join("");
  $("algoBullets").innerHTML = info.bullets.map(b=>`<li>${b}</li>`).join("");
}

/* ===== 左側流程 UI（一步一步） ===== */
function updateStepUI(){
  for(let i=1;i<=6;i++){
    const badge = $("badge"+i);
    badge.classList.remove("active","done");
    if(stepDone[i]){
      badge.textContent = "完成";
      badge.classList.add("done");
    }else if(i === currentStep){
      badge.textContent = "進行中";
      badge.classList.add("active");
    }else{
      badge.textContent = "鎖定";
    }
  }
  for(let i=1;i<=6;i++){
    $("btnStep"+i).disabled = (i !== currentStep); // 強制不能跳步
  }
  $("confirmBtn").disabled = !stepHasRun;
  $("nextBtn").disabled = !stepDone[currentStep];
  renderAlgo(currentStep);
}
updateStepUI();

/*  修正你截圖問題：切步時清空展示區，不會殘留上一個步驟內容 */
function clearResultForStep(){
  setResultHTML(`<b>等待執行</b><div class="muted" style="margin-top:6px;">請按「執行本步驟」產生此步驟的展示結果。</div>`);
}

function goStep(step){
  currentStep = step;
  stepHasRun = false;
  lastStepResult = null;
  setStatus("ready","請先「執行本步驟」，再按「確定」進入下一步。");
  clearResultForStep();
  updateStepUI();
}

/* =========================
   實作：每步演算法（真的跑）
========================= */
function getUserVector(){
  const u = getUser();
  return [u.action, u.narrative, u.puzzle, u.text];
}

function dist(a,b){
  let s = 0;
  for(let i=0;i<a.length;i++) s += (a[i]-b[i])*(a[i]-b[i]);
  return Math.sqrt(s);
}

// Step1 KNN
function step1_knn(){
  const user = getUserVector();
  const K = 5;

  neighbors = players
    .map(p=>{
      // players.json 的 pref_0_10 是 object：{action,narrative,puzzle,text}
      const pv = [p.pref_0_10.action, p.pref_0_10.narrative, p.pref_0_10.puzzle, p.pref_0_10.text];
      return { id:p.id, d: dist(user, pv) };
    })
    .sort((a,b)=>a.d-b.d)
    .slice(0,K);

  return {K, user, neighbors};
}

// Step2 Hash(Set) 候選池
function step2_candidates(){
  const set = new Set();
  for(const n of neighbors){
    const p = players.find(x=>x.id===n.id);
    if(!p) continue;
    for(const gid of p.library) set.add(gid);
  }
  candidateGameIds = [...set];
  return {count:candidateGameIds.length};
}

// Step3 二元搜尋：時間上限
function step3_timeFilter(){
  const limit = getUser().timeLimit;
  const arr = candidateGameIds
    .map(id=>games.find(g=>g.id===id))
    .filter(Boolean)
    .sort((a,b)=>a.playtime_hours - b.playtime_hours);

  // upper_bound: last index where playtime<=limit
  let l=0, r=arr.length;
  while(l<r){
    const m=(l+r)>>1;
    if(arr[m].playtime_hours<=limit) l=m+1;
    else r=m;
  }
  timeFiltered = arr.slice(0,l);
  return {limit, feasibleCount: timeFiltered.length};
}

// Step4 Union-Find（以 groupId 去重展示）
function step4_unionFind(){
  const seen = new Set();
  uniqueGames = [];
  for(const g of timeFiltered){
    if(!seen.has(g.groupId)){
      seen.add(g.groupId);
      uniqueGames.push(g);
    }
  }
  return {uniqueCount: uniqueGames.length};
}

// Step5 Greedy+DP（時間背包）— 修正版：先去重 + 2D DP + 從最佳 t 回推
function step5_greedyDP(){
  const T = getUser().timeLimit;

  //  1) 先對 uniqueGames 再做一次保底去重（同 id / 同 groupId 都不重複）
  //    若你資料 groupId 不可靠，也可以把 groupKey 改成 g.title
  const seenId = new Set();
  const seenGroup = new Set();
  const base = [];
  for (const g of uniqueGames){
    const gid = g.groupId ?? g.id;          // groupId 缺失時退回用 id
    if (seenId.has(g.id)) continue;
    if (seenGroup.has(gid)) continue;
    seenId.add(g.id);
    seenGroup.add(gid);
    base.push(g);
  }

  //  2) 算分（展示用，可調）
  for(const g of base){
    g._score = (g.rating_100/20) + (g.discount_pct/25) - (g.playtime_hours/14);
  }

  //  3) Greedy 取前 N 名當候選（縮小 DP 範圍）
  const N = Math.min(12, base.length);
  const top = [...base].sort((a,b)=>b._score-a._score).slice(0,N);

  //  4) 2D DP：dp[i][t] = 用前 i 個物品，在容量 t 下的最大分數
  const dp = Array.from({length: N+1}, () => Array(T+1).fill(0));
  const take = Array.from({length: N+1}, () => Array(T+1).fill(false));

  for(let i=1;i<=N;i++){
    const g = top[i-1];
    const w = g.playtime_hours;
    const v = g._score;

    for(let t=0;t<=T;t++){
      // 不拿
      dp[i][t] = dp[i-1][t];

      // 拿（容量夠才考慮）
      if(t>=w){
        const cand = dp[i-1][t-w] + v;
        if(cand > dp[i][t]){
          dp[i][t] = cand;
          take[i][t] = true;
        }
      }
    }
  }

  //  5) 從 dp[N][t] 的最大值位置回推（避免分數負值時 dp[T] 不是最佳）
  let bestT = 0;
  for(let t=1;t<=T;t++){
    if(dp[N][t] > dp[N][bestT]) bestT = t;
  }

  bestSet = [];
  let t = bestT;
  for(let i=N;i>=1;i--){
    if(take[i][t]){
      const g = top[i-1];
      bestSet.push(g);
      t -= g.playtime_hours;
    }
  }

  // （回推是倒著拿的，翻轉一下讓顯示更自然）
  bestSet.reverse();

  //  6) 再保底：bestSet 內不允許同 groupId 重複（理論上不會，但多一層保險）
  const usedGroup2 = new Set();
  bestSet = bestSet.filter(g=>{
    const gid = g.groupId ?? g.id;
    if(usedGroup2.has(gid)) return false;
    usedGroup2.add(gid);
    return true;
  });

  const totalTime = bestSet.reduce((s,g)=>s+g.playtime_hours,0);
  const totalScore = bestSet.reduce((s,g)=>s+g._score,0);

  return {
    topCount: N,
    bestCount: bestSet.length,
    totalTime,
    totalScore: +totalScore.toFixed(2),
    capacity: T
  };
}


// Step6 Max Flow（展示版：配額平衡）
function step6_balance(){
  const quota = {action:2, narrative:2, puzzle:2, text:2};
  const used  = {action:0, narrative:0, puzzle:0, text:0};

  const picked = [];
  const usedGameId  = new Set();   //  同一遊戲 id 不重複
  const usedGroupId = new Set();   //  同款不同版（groupId）也不重複

  // 以分數由高到低挑（展示版）
  const pool = [...bestSet].sort((a,b)=>(b._score||0)-(a._score||0));

  for(const g of pool){
    //  先擋重複（這就是你現在出現兩個一樣的關鍵修正）
    if(usedGameId.has(g.id)) continue;
    if(usedGroupId.has(g.groupId)) continue;

    // 配額檢查：每個 tag 都不能超過配額
    let ok = true;
    for(const tag of g.tags){
      if(quota[tag] !== undefined && used[tag] + 1 > quota[tag]){
        ok = false; break;
      }
    }

    if(ok){
      picked.push(g);
      usedGameId.add(g.id);
      usedGroupId.add(g.groupId);

      for(const tag of g.tags){
        if(used[tag] !== undefined) used[tag] += 1;
      }
    }
  }

  return {quota, used, pickedCount:picked.length, picked};
}


/* =========================
   展示：把結果「翻譯成看得懂的人話」
========================= */
function fmt(n, digits=2){ return Number(n).toFixed(digits); }

function renderStep1(result){
  const u = getUser();
  const top = result.neighbors[0];
  const list = result.neighbors.slice(0,5).map(n=>`玩家 ${n.id}（距離 ${fmt(n.d,3)}）`);
  return `
    <b>KNN 計算完成</b>
    <div class="muted" style="margin-top:6px;">
      你的偏好向量：動作 ${u.action}、敘事 ${u.narrative}、解謎 ${u.puzzle}、文字 ${u.text}
    </div>

    <div class="kpis">
      <div class="kpi"><div class="t">相似玩家數（K）</div><div class="v">${result.K}</div></div>
      <div class="kpi"><div class="t">最相似玩家</div><div class="v">${top ? top.id : "—"}</div></div>
      <div class="kpi"><div class="t">距離（越小越像）</div><div class="v">${top ? fmt(top.d,3) : "—"}</div></div>
    </div>

    <ul class="list">
      ${list.map(x=>`<li>${x}</li>`).join("")}
    </ul>

    <div class="muted" style="margin-top:8px;">
      下一步會從這些相似玩家的收藏庫中，合併出「候選遊戲池」。
    </div>
  `;
}

function renderStep2(result){
  return `
    <b>候選遊戲池建立完成</b>
    <div class="kpis">
      <div class="kpi"><div class="t">候選遊戲數</div><div class="v">${result.count}</div></div>
      <div class="kpi"><div class="t">方法</div><div class="v">Hash / Set 去重</div></div>
    </div>
    <ul class="list">
      <li>把相似玩家的收藏庫合併</li>
      <li>使用雜湊結構快速去除重複遊戲 ID</li>
      <li>得到候選池，交給下一步做時間上限篩選</li>
    </ul>
  `;
}

function renderStep3(result){
  const limit = result.limit;
  const sample = timeFiltered.slice(0,6).map(g=>`${g.name}（${g.playtime_hours}h）`);
  return `
    <b>時間上限篩選完成</b>
    <div class="kpis">
      <div class="kpi"><div class="t">時間上限</div><div class="v">${limit} 小時</div></div>
      <div class="kpi"><div class="t">可玩遊戲數</div><div class="v">${result.feasibleCount}</div></div>
      <div class="kpi"><div class="t">方法</div><div class="v">排序 + 二元搜尋</div></div>
    </div>
    <div class="muted" style="margin-top:6px;">示例（前幾款可玩遊戲）：</div>
    <ul class="list">
      ${sample.map(x=>`<li>${x}</li>`).join("") || "<li>（沒有符合時間上限的遊戲）</li>"}
    </ul>
  `;
}

function renderStep4(result){
  const sample = uniqueGames.slice(0,6).map(g=>`${g.name}（groupId: ${g.groupId}）`);
  return `
    <b>版本去重完成</b>
    <div class="kpis">
      <div class="kpi"><div class="t">去重後遊戲數</div><div class="v">${result.uniqueCount}</div></div>
      <div class="kpi"><div class="t">去重依據</div><div class="v">groupId 合併</div></div>
    </div>
    <ul class="list">
      <li>同一款遊戲可能有不同版本/包（用 groupId 視為同集合）</li>
      <li>每個 groupId 只保留 1 個代表，避免推薦重複</li>
    </ul>
    <div class="muted" style="margin-top:6px;">示例（前幾款去重後遊戲）：</div>
    <ul class="list">
      ${sample.map(x=>`<li>${x}</li>`).join("") || "<li>（沒有可用遊戲）</li>"}
    </ul>
  `;
}

function renderStep5(result){
  const list = bestSet.slice(0,8).map(g=>`${g.name}（${g.playtime_hours}h｜分數 ${fmt(g._score,2)}）`);
  return `
    <b>最佳組合（Greedy + DP）完成</b>
    <div class="kpis">
      <div class="kpi"><div class="t">時間容量</div><div class="v">${result.capacity} 小時</div></div>
      <div class="kpi"><div class="t">選到遊戲數</div><div class="v">${result.bestCount}</div></div>
      <div class="kpi"><div class="t">總遊玩時間</div><div class="v">${result.totalTime} 小時</div></div>
      <div class="kpi"><div class="t">總符合度</div><div class="v">${result.totalScore}</div></div>
    </div>
    <ul class="list">
      <li>Greedy：先取高分候選（Top-${result.topCount}）</li>
      <li>DP：在時間限制下，找總分最高的組合（0/1 背包）</li>
    </ul>
    <div class="muted" style="margin-top:6px;">示例（最佳組合前幾款）：</div>
    <ul class="list">
      ${list.map(x=>`<li>${x}</li>`).join("") || "<li>（沒有可行組合）</li>"}
    </ul>
  `;
}

function renderStep6(result){
  const usage = result.used;
  const picked = result.picked.slice(0,8).map(g=>`${g.name}（${g.tags.map(tagToZh).join("、")}）`);
  const usageZh = `動作 ${usage.action}｜敘事 ${usage.narrative}｜解謎 ${usage.puzzle}｜文字 ${usage.text}`;
  return `
    <b>類型平衡（Max Flow 概念展示）完成</b>
    <div class="kpis">
      <div class="kpi"><div class="t">每類配額</div><div class="v">最多 2 款</div></div>
      <div class="kpi"><div class="t">實際分布</div><div class="v">${usageZh}</div></div>
      <div class="kpi"><div class="t">平衡後遊戲數</div><div class="v">${result.pickedCount}</div></div>
    </div>
    <ul class="list">
      <li>把類型當作資源配額，避免推薦清單「全偏某一類」</li>
      <li>此頁以配額平衡展示最大流的「資源分配」精神</li>
    </ul>
    <div class="muted" style="margin-top:6px;">示例（平衡後前幾款）：</div>
    <ul class="list">
      ${picked.map(x=>`<li>${x}</li>`).join("") || "<li>（沒有可行結果）</li>"}
    </ul>
  `;
}

/* =========================
   右側結論（本步 + 累積）
========================= */
function makeConclusionText(step){
  if(step === 1){
    const u = getUser();
    const top = neighbors[0];
    return `偏好（動作${u.action}/敘事${u.narrative}/解謎${u.puzzle}/文字${u.text}）→ 找到 ${neighbors.length} 位相似玩家；最相似：${top ? top.id : "—"}。`;
  }
  if(step === 2){
    return `合併相似玩家收藏庫（Hash/Set 去重）→ 候選遊戲池 ${candidateGameIds.length} 款。`;
  }
  if(step === 3){
    const limit = getUser().timeLimit;
    return `依時間上限 ${limit} 小時（Binary Search）→ 可玩遊戲 ${timeFiltered.length} 款。`;
  }
  if(step === 4){
    return `以 groupId 合併同款不同版（Union-Find 概念）→ 去重後 ${uniqueGames.length} 款。`;
  }
  if(step === 5){
    const totalTime = bestSet.reduce((s,g)=>s+g.playtime_hours,0);
    return `Greedy + DP（背包）→ 最佳組合 ${bestSet.length} 款；總時間 ${totalTime} 小時。`;
  }
  if(step === 6){
    // 這步的 picked 不會保存全域，直接用 lastStepResult
    return `類型平衡（最大流概念展示）→ 讓推薦清單更平均、避免偏科。`;
  }
  return "（未定義結論）";
}

function updateConclusionUI(text){
  $("stepConclusionNow").textContent = text;

  conclusionHistory = conclusionHistory.filter(x => x.step !== currentStep);
  conclusionHistory.push({ step: currentStep, text });
  conclusionHistory.sort((a,b)=>a.step-b.step);

  const ul = $("conclusionList");
  ul.innerHTML = "";
  for(const item of conclusionHistory){
    const li = document.createElement("li");
    li.textContent = `Step ${item.step}：${item.text}`;
    ul.appendChild(li);
  }
}

/* =========================
   核心互動：執行 → 確定 → 下一步
========================= */
function runCurrentStep(){
  if(!games.length || !players.length){
    setStatus("err","資料尚未載入完成，請稍候再試。");
    return;
  }

  try{
    let html = "";
    if(currentStep === 1){
      const r = step1_knn();
      lastStepResult = r;
      html = renderStep1(r);
    }
    if(currentStep === 2){
      const r = step2_candidates();
      lastStepResult = r;
      html = renderStep2(r);
    }
    if(currentStep === 3){
      const r = step3_timeFilter();
      lastStepResult = r;
      html = renderStep3(r);
    }
    if(currentStep === 4){
      const r = step4_unionFind();
      lastStepResult = r;
      html = renderStep4(r);
    }
    if(currentStep === 5){
      const r = step5_greedyDP();
      lastStepResult = r;
      html = renderStep5(r);
    }
    if(currentStep === 6){
      const r = step6_balance();
      lastStepResult = r;
      html = renderStep6(r);
    }

    setResultHTML(html);
    stepHasRun = true;
    setStatus("ready","已執行  請按「確定」鎖定結果，才能進入下一步。");
    updateStepUI();

  }catch(e){
    setStatus("err","執行失敗：" + e.message);
  }
}

function confirmStep(){
  if(!stepHasRun){
    setStatus("err","請先按「執行本步驟」。");
    return;
  }

  stepDone[currentStep] = true;
  stepHasRun = false;

  const text = makeConclusionText(currentStep);
  updateConclusionUI(text);

  setStatus("done","已確定  請按「下一步」繼續。");
  updateStepUI();
}

function nextStep(){
  if(!stepDone[currentStep]) return;

  if(currentStep >= 6){
    setStatus("done","流程已完成  可以調整偏好或時間後重設再跑一次。");
    return;
  }

  // 解鎖下一步
  currentStep += 1;
  stepHasRun = false;
  lastStepResult = null;

  setStatus("ready","進入下一步。請先「執行本步驟」，再按「確定」。");
  clearResultForStep();
  updateStepUI();
}

function resetAll(){
  currentStep = 1;
  for(let i=1;i<=6;i++) stepDone[i] = false;
  stepHasRun = false;

  neighbors = [];
  candidateGameIds = [];
  timeFiltered = [];
  uniqueGames = [];
  bestSet = [];

  conclusionHistory = [];
  lastStepResult = null;

  $("stepConclusionNow").textContent = "尚未執行";
  $("conclusionList").innerHTML = "<li>尚未開始</li>";

  setStatus("ready","請先「執行本步驟」，再按「確定」進入下一步。");
  clearResultForStep();
  updateStepUI();
}

/* =========================
   GitHub Pages 資料載入（ 修正 404/Unexpected token <）
========================= */
Promise.all([
  fetch("./games.json").then(r => { if(!r.ok) throw new Error("games.json 讀取失敗（404）"); return r.json(); }),
  fetch("./players.json").then(r => { if(!r.ok) throw new Error("players.json 讀取失敗（404）"); return r.json(); })
]).then(([g,p])=>{
  games = g;
  players = p;

  clearResultForStep();
  setStatus("ready",`資料載入成功  games: ${games.length}｜players: ${players.length}。請從 Step 1 開始。`);

}).catch(err=>{
  setResultHTML(`<b>資料載入失敗 </b><div class="muted" style="margin-top:6px;">${err.message}<br>請確認 games.json / players.json 與 index.html 同一層，並透過 GitHub Pages 網址開啟（不要用本機 file://）。</div>`);
  setStatus("err","資料載入失敗：請確認檔案路徑與 GitHub Pages。");
});
</script>
</body>
</html>
