<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數學打地鼠 - 數字大亂鬥</title>
    <style>
        :root {
            --primary-color: #FFB347;
            --bg-color: #87CEEB;
            --mole-bg: #8B4513;
            --energy-color: #4CAF50;
            --danger-color: #FF5252;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            cursor: none; /* 隱藏系統鼠標，改用槌子 */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* HUD */
        #hud {
            width: 90%;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 10px;
            margin-top: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #333;
        }

        #energy-bar-container {
            width: 100%;
            height: 15px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #555;
        }

        #energy-bar {
            width: 100%;
            height: 100%;
            background: var(--energy-color);
            transition: width 0.2s, background 0.2s;
        }

        /* 目標數字 */
        #target-board {
            background: #FFD700;
            border: 4px solid #FF8C00;
            border-radius: 20px;
            padding: 10px 30px;
            margin: 10px 0;
            text-align: center;
            font-size: 2.5rem;
            font-weight: 900;
            color: #d35400;
            box-shadow: 0 5px 0 #c0392b;
            position: relative;
            animation: bounceIn 0.5s;
        }
        
        #target-label {
            font-size: 1rem;
            color: #333;
            display: block;
            margin-bottom: -5px;
        }

        /* 網格 */
        #grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            width: 90%;
            max-width: 400px;
            margin: auto;
        }

        .hole {
            background: var(--mole-bg);
            border-radius: 50%;
            aspect-ratio: 1;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 10px 10px rgba(0,0,0,0.5);
            border: 4px solid #5D4037;
        }

        .mole {
            width: 80%;
            height: 90%;
            background: #f5f5f5;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="30" cy="40" r="5" fill="black"/><circle cx="70" cy="40" r="5" fill="black"/><path d="M40 60 Q50 70 60 60" stroke="black" stroke-width="3" fill="none"/></svg>');
            background-size: cover;
            position: absolute;
            bottom: -100%;
            left: 10%;
            border-radius: 40% 40% 10% 10%;
            transition: bottom 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 加入一點彈跳感 */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            cursor: none; /* 確保游標在上面時也是隱藏 */
            box-shadow: 0 4px 5px rgba(0,0,0,0.2);
        }

        .mole.up {
            bottom: 0;
        }

        /* 被打到的樣子 */
        .mole.hit {
            background-color: #ffcccc;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M25 35 L35 45 M35 35 L25 45" stroke="black" stroke-width="4"/><path d="M65 35 L75 45 M75 35 L65 45" stroke="black" stroke-width="4"/><circle cx="50" cy="65" r="10" fill="black"/></svg>');
            transition: bottom 0.1s ease-in;
        }

        .mole-sign {
            background: white;
            border: 2px solid #333;
            padding: 2px 5px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.2rem;
            margin-top: 50%;
            pointer-events: none;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        /* 鎚子 */
        #hammer {
            position: fixed; /* 使用 fixed 避免受父容器影響 */
            top: 0;
            left: 0;
            width: 70px;
            height: 70px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect x="30" y="10" width="40" height="50" fill="brown" stroke="black" stroke-width="2"/><rect x="45" y="60" width="10" height="30" fill="tan" stroke="black" stroke-width="2"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transform-origin: bottom right;
            transition: transform 0.05s;
            pointer-events: none; /* 讓點擊能穿透槌子打到地鼠 */
            z-index: 9999;
            margin-left: -15px; /* 稍微校正中心點 */
            margin-top: -30px;
        }

        .hammer-hit {
            transform: rotate(-45deg);
        }

        /* 特效 */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-screen {
            animation: shake 0.5s;
            background-color: #ffdddd;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        .float-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            color: #ff0000;
            pointer-events: none;
            animation: floatUp 1s forwards;
            z-index: 20;
            text-shadow: 1px 1px 0 #fff;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        /* Modal */
        #modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: default; /* 選單時恢復游標 */
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 80%;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2rem;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>

    <div id="hammer"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-row">
                <span id="score-display">分數: 0</span>
                <span id="level-display">Lv. 1</span>
            </div>
            <div id="energy-bar-container">
                <div id="energy-bar"></div>
            </div>
            <div class="hud-row" style="font-size: 1rem; color: #666; margin-top:5px;">
                <span id="combo-display">Combo: 0</span>
            </div>
        </div>

        <div id="target-board">
            <span id="target-label">目標數字</span>
            <span id="target-number">??</span>
        </div>

        <div id="grid">
            <div class="hole" id="hole-0"><div class="mole" id="mole-0"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-1"><div class="mole" id="mole-1"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-2"><div class="mole" id="mole-2"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-3"><div class="mole" id="mole-3"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-4"><div class="mole" id="mole-4"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-5"><div class="mole" id="mole-5"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-6"><div class="mole" id="mole-6"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-7"><div class="mole" id="mole-7"><div class="mole-sign"></div></div></div>
            <div class="hole" id="hole-8"><div class="mole" id="mole-8"><div class="mole-sign"></div></div></div>
        </div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h1 id="modal-title">數學打地鼠</h1>
            <p id="modal-desc">找出能算出目標數字的算式！<br>例如：目標 24 -> 打 6x4</p>
            <button onclick="startGame()">開始遊戲</button>
        </div>
    </div>

    <script>
        // 遊戲狀態變數
        let score = 0;
        let level = 1;
        let energy = 100;
        let combo = 0;
        let targetNumber = 0;
        let correctCountForTarget = 0;
        let correctTotalCount = 0;
        let isGameRunning = false;
        let moles = []; 
        let spawnTimer = null;
        let moleTimers = []; 
        
        // 設定參數
        const REQUIRED_HITS_SWITCH = 3; 
        const HITS_TO_LEVEL_UP = 10; 
        const MAX_ENERGY = 100;
        
        // DOM 元素
        const energyBar = document.getElementById('energy-bar');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const comboDisplay = document.getElementById('combo-display');
        const targetNumberDisplay = document.getElementById('target-number');
        const hammer = document.getElementById('hammer');

        function init() {
            // 滑鼠移動與點擊
            document.addEventListener('mousemove', moveHammer);
            document.addEventListener('mousedown', swingHammer);
            document.addEventListener('mouseup', resetHammer);
            
            // 綁定地鼠點擊
            for(let i=0; i<9; i++) {
                const mole = document.getElementById(`mole-${i}`);
                // 注意：因為我們隱藏了滑鼠，點擊事件可能會被上層元素遮擋
                // 但因為 hammer 是 pointer-events: none，所以點擊會穿透到下層
                mole.addEventListener('mousedown', () => hitMole(i));
                moles.push({ 
                    element: mole, 
                    sign: mole.querySelector('.mole-sign'), 
                    isUp: false, 
                    isCorrect: false
                });
            }
        }

        function moveHammer(e) {
            hammer.style.left = e.clientX + 'px';
            hammer.style.top = e.clientY + 'px';
        }

        function swingHammer() {
            hammer.classList.add('hammer-hit');
        }

        function resetHammer() {
            hammer.classList.remove('hammer-hit');
        }

        function updateHammerSkin() {
            let svgColor = "brown"; 
            let headColor = "tan";
            
            if (level >= 10) { 
                svgColor = "#00BFFF"; headColor = "#E0FFFF";
            } else if (level >= 7) { 
                svgColor = "#FFD700"; headColor = "#FFFFE0";
            } else if (level >= 4) { 
                svgColor = "#708090"; headColor = "#C0C0C0";
            }

            const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect x="30" y="10" width="40" height="50" fill="${svgColor}" stroke="black" stroke-width="2"/><rect x="45" y="60" width="10" height="30" fill="${headColor}" stroke="black" stroke-width="2"/></svg>`;
            hammer.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svgContent)}')`;
        }

        function startGame() {
            document.getElementById('modal').style.display = 'none';
            // 遊戲開始時隱藏滑鼠
            document.body.style.cursor = 'none';
            document.getElementById('modal').style.cursor = 'none';
            
            score = 0;
            level = 1;
            energy = 100;
            combo = 0;
            correctCountForTarget = 0;
            correctTotalCount = 0;
            isGameRunning = true;
            
            updateHUD();
            updateHammerSkin();
            generateNewTarget();
            gameLoop();
        }

        function gameOver() {
            isGameRunning = false;
            clearTimeout(spawnTimer);
            clearAllMoles();
            // 遊戲結束恢復滑鼠，方便點擊按鈕
            document.body.style.cursor = 'default';
            document.getElementById('modal').style.cursor = 'default';
            
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('modal-title').innerText = "遊戲結束";
            document.getElementById('modal-desc').innerText = `最終分數: ${score}\n最高等級: ${level}`;
            document.querySelector('#modal button').innerText = "再玩一次";
        }

        function generateNewTarget() {
            let min, max;
            let validTarget = false;
            let tempTarget = 0;

            if (level <= 3) { min = 4; max = 81; }
            else if (level <= 6) { min = 20; max = 200; }
            else if (level <= 9) { min = 100; max = 500; }
            else { min = 500; max = 999; }

            while (!validTarget) {
                tempTarget = Math.floor(Math.random() * (max - min + 1)) + min;
                for (let i = 2; i <= 15; i++) {
                    if (tempTarget % i === 0 && tempTarget / i > 1) {
                        validTarget = true;
                        break;
                    }
                }
            }

            targetNumber = tempTarget;
            targetNumberDisplay.innerText = targetNumber;
            
            const board = document.getElementById('target-board');
            board.style.animation = 'none';
            board.offsetHeight;
            board.style.animation = 'bounceIn 0.5s';
        }

        function generateEquation(target, isCorrect, usedLabels = []) {
            let equation = "";
            let retryCount = 0;
            
            // 嘗試生成不重複的算式，最多嘗試 10 次
            do {
                if (isCorrect) {
                    let factors = [];
                    for (let i = 2; i <= Math.sqrt(target); i++) {
                        if (target % i === 0) factors.push(i);
                    }
                    if (factors.length === 0) {
                        equation = `1 x ${target}`; // 萬一沒因數 (極少發生)
                    } else {
                        let f1 = factors[Math.floor(Math.random() * factors.length)];
                        let f2 = target / f1;
                        // 隨機交換順序 (交換律)
                        equation = Math.random() > 0.5 ? `${f1} x ${f2}` : `${f2} x ${f1}`;
                    }
                } else {
                    let offset = Math.floor(Math.random() * 5) + 1;
                    offset = Math.random() > 0.5 ? offset : -offset;
                    let fakeTarget = target + offset;
                    if (fakeTarget < 2) fakeTarget = 2;
                    let f1 = Math.floor(Math.sqrt(fakeTarget));
                    if (f1 < 2) f1 = 2;
                    let f2 = Math.floor(fakeTarget / f1);
                    if (f1 * f2 === target) f2 += 1;
                    // 隨機交換順序
                    equation = Math.random() > 0.5 ? `${f1} x ${f2}` : `${f2} x ${f1}`;
                }
                retryCount++;
            } while (usedLabels.includes(equation) && retryCount < 10);

            return equation;
        }

        function gameLoop() {
            if (!isGameRunning) return;

            let spawnInterval = Math.max(800, 2000 - (level * 100) - (combo * 20));
            if (correctCountForTarget === 0) spawnInterval += 1000;

            spawnTimer = setTimeout(() => {
                spawnMoles();
                gameLoop();
            }, spawnInterval);
        }

        function spawnMoles() {
            let activeMoles = moles.filter(m => m.isUp).length;
            if (activeMoles > 2) return;

            let count = Math.floor(Math.random() * 3) + 1;
            let indices = [0, 1, 2, 3, 4, 5, 6, 7, 8].sort(() => Math.random() - 0.5);
            
            let hasCorrect = false;
            let currentWaveLabels = []; // 紀錄這一波生成的算式，避免重複

            for (let i = 0; i < count; i++) {
                let idx = indices[i];
                let moleObj = moles[idx];
                
                if (moleObj.isUp) continue;

                let isCorrect = false;
                if (i === count - 1 && !hasCorrect) {
                    isCorrect = true;
                } else {
                    isCorrect = Math.random() > 0.6;
                }
                
                if (isCorrect) hasCorrect = true;

                // 生成算式時傳入已生成的標籤清單
                let eqText = generateEquation(targetNumber, isCorrect, currentWaveLabels);
                currentWaveLabels.push(eqText);

                // 使用 setTimeout 創造「時間差」(Stagger Effect)
                // 每個地鼠間隔 200 毫秒出現
                setTimeout(() => {
                    // 再次檢查遊戲是否還在進行 (防止 GameOver 後還有地鼠冒出來)
                    if(isGameRunning) {
                        popUpMole(idx, isCorrect, eqText);
                    }
                }, i * 200);
            }
        }

        function popUpMole(idx, isCorrect, text) {
            const moleObj = moles[idx];
            // 雙重檢查：防止這個洞在延遲期間被其他邏輯佔用了
            if(moleObj.isUp) return;

            moleObj.isUp = true;
            moleObj.isCorrect = isCorrect;
            moleObj.sign.innerText = text;
            
            moleObj.element.classList.remove('hit');
            moleObj.element.classList.add('up');

            let stayTime = Math.max(1500, 5000 - (level * 300) - (combo * 50));
            if (correctCountForTarget === 0) stayTime += 1000;

            let timerId = setTimeout(() => {
                if (moleObj.isUp) {
                    retractMole(idx);
                    if (moleObj.isCorrect) {
                        handleMistake(idx, "Miss!");
                    }
                }
            }, stayTime);
            
            moleTimers[idx] = timerId;
        }

        function retractMole(idx) {
            const moleObj = moles[idx];
            moleObj.isUp = false;
            moleObj.element.classList.remove('up');
            if (moleTimers[idx]) clearTimeout(moleTimers[idx]);
        }

        function clearAllMoles() {
            for(let i=0; i<9; i++) {
                retractMole(i);
            }
        }

        function hitMole(idx) {
            if (!isGameRunning) return;
            const moleObj = moles[idx];
            
            if (!moleObj.isUp || moleObj.element.classList.contains('hit')) return;

            moleObj.element.classList.add('hit');
            
            setTimeout(() => {
                retractMole(idx);
            }, 300);

            if (moleObj.isCorrect) {
                handleSuccess(idx);
            } else {
                handleMistake(idx, "錯了!");
            }
        }

        function handleSuccess(idx) {
            combo++;
            score += (10 * combo);
            correctCountForTarget++;
            correctTotalCount++;
            
            energy = Math.min(MAX_ENERGY, energy + 5);
            
            showFloatText(idx, "Great!", "#4CAF50");

            if (correctTotalCount % HITS_TO_LEVEL_UP === 0) {
                level++;
                energy = MAX_ENERGY;
                updateHammerSkin();
                showFloatText(idx, "Level Up!", "#FFD700");
            }

            if (correctCountForTarget >= REQUIRED_HITS_SWITCH) {
                correctCountForTarget = 0;
                clearAllMoles();
                setTimeout(generateNewTarget, 600); // 稍微加長換題等待時間
            }

            updateHUD();
        }

        function handleMistake(idx, msg) {
            combo = 0;
            energy -= 15;
            
            document.body.classList.add('shake-screen');
            setTimeout(() => document.body.classList.remove('shake-screen'), 500);

            showFloatText(idx, `${msg} (是 ${targetNumber})`, "#FF5252");

            clearAllMoles();

            if (energy <= 0) {
                energy = 0;
                updateHUD();
                gameOver();
            } else {
                updateHUD();
                clearTimeout(spawnTimer);
                setTimeout(gameLoop, 1500);
            }
        }

        function showFloatText(moleIdx, text, color) {
            const mole = document.getElementById(`mole-${moleIdx}`);
            const rect = mole.getBoundingClientRect();
            const floatDiv = document.createElement('div');
            floatDiv.innerText = text;
            floatDiv.className = 'float-text';
            floatDiv.style.color = color;
            floatDiv.style.left = (rect.left + 20) + 'px';
            floatDiv.style.top = (rect.top) + 'px';
            document.body.appendChild(floatDiv);

            setTimeout(() => {
                floatDiv.remove();
            }, 1000);
        }

        function updateHUD() {
            scoreDisplay.innerText = `分數: ${score}`;
            levelDisplay.innerText = `Lv. ${level}`;
            comboDisplay.innerText = `Combo: ${combo}`;
            energyBar.style.width = `${energy}%`;
            
            if (energy < 30) {
                energyBar.style.backgroundColor = "var(--danger-color)";
            } else {
                energyBar.style.backgroundColor = "var(--energy-color)";
            }
        }

        init();
    </script>
</body>
</html>
