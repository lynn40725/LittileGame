<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šå®Œç¾æ‹¼åœ–ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: #fff8e1; /* æŸ”å’Œçš„ç±³é»ƒè‰² */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overscroll-behavior: none;
            user-select: none;
        }
        h1 { color: #4e342e; margin-bottom: 5px; font-size: 24px; }
        
        .game-wrapper {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            max-width: 100%;
            border: 4px solid #ffb74d;
        }

        canvas {
            border: 3px solid #795548;
            border-radius: 8px;
            cursor: grab;
            background-color: #eceff1;
            touch-action: none;
        }
        canvas:active { cursor: grabbing; }
        
        .sidebar {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .info-panel {
            background: #e0f7fa;
            padding: 15px;
            border-radius: 15px;
            border-left: 6px solid #00bcd4;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .info-panel h3 { margin: 0 0 8px 0; font-size: 18px; color: #00838f; }
        .stat { font-size: 16px; margin-bottom: 5px; color: #37474f; }
        .highlight { color: #d81b60; font-weight: bold; font-size: 1.2em; }
        
        .controls {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 12px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s;
            font-weight: bold;
            color: white;
            box-shadow: 0 4px 0 rgba(0,0,0,0.15);
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new-game { background-color: #66bb6a; }
        #btn-hint { background-color: #ffa726; }

        .math-feedback {
            font-size: 18px;
            text-align: center;
            min-height: 30px;
            color: #5d4037;
            font-weight: bold;
            margin: 10px 0;
            padding: 8px;
            background: #fff;
            border-radius: 10px;
            border: 2px dashed #8d6e63;
            width: 90%;
            max-width: 800px;
        }
        .instruction {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: -5px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <h1>ğŸ§© èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šå®Œç¾æ‹¼åœ–</h1>
    <div class="instruction">ğŸ–±ï¸ æ‹–æ›³ç‰©å“ | ğŸ‘† <b>é›™æ“Š(Double Click)ç‰©å“å¯æ—‹è½‰</b></div>
    <div class="math-feedback" id="math-feedback">æ­¡è¿æŒ‘æˆ°ï¼è«‹æŠŠæ‰€æœ‰ç‰©å“å¡é€²èƒŒåŒ…ï¼</div>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="900" height="550"></canvas>

        <div class="sidebar">
            <div class="info-panel">
                <h3>ğŸ“Š é€²åº¦å ±å‘Š</h3>
                <div class="stat">ç›®æ¨™ï¼šå¡«æ»¿ 80 æ ¼</div>
                <div class="stat">ç›®å‰è¦†è“‹ç‡ï¼š<span id="coverage" class="highlight">0%</span></div>
                <div class="stat" id="win-msg" style="display:none; color:green; font-weight:bold;">ğŸ‰ æŒ‘æˆ°æˆåŠŸï¼</div>
            </div>

            <div class="info-panel" style="background: #fff3e0; border-left-color: #ff9800;">
                <h3>ğŸ“ ç‰©å“å¹¾ä½•</h3>
                <div id="current-item-info" style="line-height: 1.6;">
                    é¸å–ç‰©å“æŸ¥çœ‹å½¢ç‹€èˆ‡é¢ç©
                </div>
            </div>

            <div class="controls">
                <button id="btn-new-game">ğŸ”„ æ–°çš„é—œå¡ (é‡ç½®)</button>
                <button id="btn-hint">ğŸ’¡ æ—‹è½‰æç¤º</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiItemInfo = document.getElementById('current-item-info');
        const uiFeedback = document.getElementById('math-feedback');
        const uiWinMsg = document.getElementById('win-msg');

        // éŠæˆ²åƒæ•¸
        const GRID_SIZE = 45; 
        const GRID_COLS = 10; 
        const GRID_ROWS = 8;  
        const OFFSET_X = 40;
        const OFFSET_Y = 60;
        const BACKPACK_W = GRID_COLS * GRID_SIZE;
        const BACKPACK_H = GRID_ROWS * GRID_SIZE;

        let items = [];
        let draggedItem = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let lastClickTime = 0; // ç”¨æ–¼åµæ¸¬é›™æ“Š

        // --- å®šç¾©ç‰©å“åŸå‹èˆ‡ç¹ªåœ–é¢¨æ ¼ ---
        const ITEM_TEMPLATES = {
            'ruler': { name: "é•·å°º", type: 'tool', color: '#fdd835', draw: drawRuler },
            'book': { name: "èª²æœ¬", type: 'book', color: '#42a5f5', draw: drawBook },
            'notebook': { name: "ç­†è¨˜æœ¬", type: 'book', color: '#66bb6a', draw: drawNotebook },
            'pencil_box': { name: "é‰›ç­†ç›’", type: 'tool', color: '#ef5350', draw: drawPencilBox },
            'eraser': { name: "æ©¡çš®æ“¦", type: 'tool', color: '#bdbdbd', draw: drawEraser },
            'headphones': { name: "è€³æ©Ÿ", type: 'tech', color: '#ab47bc', draw: drawHeadphones },
            'gameboy': { name: "éŠæˆ²æ©Ÿ", type: 'tech', color: '#26c6da', draw: drawGameboy },
            'tetris': { name: "ç©æœ¨", type: 'toy', color: '#ff7043', draw: drawTetris }
        };

        // --- å½¢ç‹€å®šç¾© (Puzzle Pieces) ---
        // ç‚ºäº†ä¿è­‰èƒ½å¡«æ»¿ï¼Œæˆ‘å€‘ä½¿ç”¨ç°¡å–®çš„è²ªå©ªæ¼”ç®—æ³•ç”Ÿæˆæ‹¼åœ–
        // é€™è£¡å®šç¾©å¯ç”¨çš„å½¢ç‹€æ±  (Shape Pool)
        const SHAPES = [
            [[1,1,1,1]], // 1x4 (Ruler)
            [[1,1,1],[1,0,0]], // L-shape
            [[1,1],[1,1]], // 2x2 Square
            [[1,1,1],[0,1,0]], // T-shape
            [[1,1],[1,0],[1,0]], // L-shape long
            [[1,1,1]], // 1x3
            [[1,1]], // 1x2
            [[1]] // 1x1 (Filler)
        ];

        class Item {
            constructor(shape, x, y, templateKey) {
                this.shape = shape; // 2D array (0/1)
                this.x = x;
                this.y = y;
                this.template = ITEM_TEMPLATES[templateKey];
                this.color = this.template.color;
                this.isInside = false;
                this.rotationIndex = 0; // 0, 1, 2, 3
                
                this.updateDimensions();
            }

            updateDimensions() {
                this.rows = this.shape.length;
                this.cols = this.shape[0].length;
                this.area = 0;
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) this.area++;
                    }
                }
            }

            rotate() {
                // çŸ©é™£æ—‹è½‰ 90 åº¦
                const newRows = this.cols;
                const newCols = this.rows;
                let newShape = new Array(newRows).fill(0).map(() => new Array(newCols).fill(0));

                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        // é †æ™‚é‡æ—‹è½‰: (r, c) -> (c, rows-1-r)
                        newShape[c][this.rows - 1 - r] = this.shape[r][c];
                    }
                }
                this.shape = newShape;
                this.rotationIndex = (this.rotationIndex + 1) % 4;
                this.updateDimensions();
            }

            draw(ctx) {
                // å‘¼å«å°ˆå±¬çš„ç¹ªåœ–å‡½æ•¸ï¼Œæˆ–è€…ä½¿ç”¨é è¨­
                if (this.template.draw) {
                    this.template.draw(ctx, this);
                } else {
                    drawGenericBlock(ctx, this);
                }
            }

            hitTest(mx, my) {
                // ç°¡å–® Bounding Box
                if (mx < this.x || mx > this.x + this.cols * GRID_SIZE ||
                    my < this.y || my > this.y + this.rows * GRID_SIZE) {
                    return false;
                }
                // ç²¾ç¢ºåƒç´ 
                const col = Math.floor((mx - this.x) / GRID_SIZE);
                const row = Math.floor((my - this.y) / GRID_SIZE);
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    return this.shape[row][col] === 1;
                }
                return false;
            }
        }

        // --- è¦–è¦ºç¹ªåœ–å‡½æ•¸ (è®“ç‰©å“çœ‹èµ·ä¾†åƒå¯¦ç‰©) ---
        
        function drawBaseShape(ctx, item, colorOverride) {
            ctx.fillStyle = colorOverride || item.color;
            
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        const dx = item.x + c * GRID_SIZE;
                        const dy = item.y + r * GRID_SIZE;
                        
                        // ä¸»é«”
                        ctx.fillRect(dx, dy, GRID_SIZE, GRID_SIZE);
                        
                        // ç«‹é«”é‚Šæ¡†æ„Ÿ
                        ctx.strokeStyle = "rgba(0,0,0,0.1)";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(dx, dy, GRID_SIZE, GRID_SIZE);
                        
                        // å¤–è¼ªå»“ (ç¨å¾Œæ•´é«”ç•«æœƒæ›´å¥½ï¼Œé€™è£¡ç°¡åŒ–)
                        ctx.strokeStyle = "rgba(0,0,0,0.3)";
                        ctx.strokeRect(dx, dy, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
        }

        function drawRuler(ctx, item) {
            drawBaseShape(ctx, item);
            ctx.strokeStyle = "#3e2723";
            ctx.lineWidth = 2;
            
            // ç•«åˆ»åº¦
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        const dx = item.x + c * GRID_SIZE;
                        const dy = item.y + r * GRID_SIZE;
                        // æ ¹æ“šé•·å¯¬æ¯”åˆ¤æ–·åˆ»åº¦æ–¹å‘ï¼Œé€™è£¡ç°¡å–®ç•«åœ¨ä¸Šæ–¹
                        ctx.beginPath();
                        for(let i=1; i<4; i++) {
                            ctx.moveTo(dx + i*10, dy);
                            ctx.lineTo(dx + i*10, dy + 10 + (i%2)*5);
                        }
                        ctx.stroke();
                        // æ•¸å­—
                        ctx.fillStyle = "#3e2723";
                        ctx.font = "10px Arial";
                        ctx.fillText((c+1), dx + 25, dy + 25);
                    }
                }
            }
        }

        function drawBook(ctx, item) {
            drawBaseShape(ctx, item);
            // æ›¸è„Š
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        const dx = item.x + c * GRID_SIZE;
                        const dy = item.y + r * GRID_SIZE;
                        // å¦‚æœæ˜¯å·¦é‚Šç¬¬ä¸€åˆ—ï¼Œç•«æ›¸è„Š
                        if(c === 0 || (c>0 && item.shape[r][c-1]===0)) {
                            ctx.fillRect(dx, dy, 10, GRID_SIZE);
                        }
                    }
                }
            }
            // æ–‡å­—
            ctx.fillStyle = "white";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            let cx = item.x + (item.cols * GRID_SIZE)/2;
            let cy = item.y + (item.rows * GRID_SIZE)/2;
            ctx.fillText("MATH", cx, cy);
        }

        function drawNotebook(ctx, item) {
            drawBaseShape(ctx, item);
            // èºæ—‹åœˆåœˆ
            ctx.fillStyle = "#444";
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        const dx = item.x + c * GRID_SIZE;
                        const dy = item.y + r * GRID_SIZE;
                        if(r === 0) { // ä¸Šæ–¹ç•«åœˆåœˆ
                             ctx.beginPath();
                             ctx.arc(dx + 10, dy + 5, 3, 0, Math.PI*2);
                             ctx.arc(dx + 20, dy + 5, 3, 0, Math.PI*2);
                             ctx.arc(dx + 30, dy + 5, 3, 0, Math.PI*2);
                             ctx.fill();
                        }
                    }
                }
            }
        }

        function drawHeadphones(ctx, item) {
            drawBaseShape(ctx, item);
            // é€™è£¡ç°¡å–®ç”¨é¡è‰²å€åˆ†ï¼Œå¦‚æœæ˜¯è€³ç½©éƒ¨åˆ†ç•«æ·±è‰²
            ctx.fillStyle = "#4a148c"; 
            // å‡è¨­ U å‹çš„å…©ç«¯æ˜¯è€³ç½©ï¼Œé€™è£¡ç°¡åŒ–è™•ç†ï¼šç•«ä¸­é–“çš„åœ–ç¤º
            ctx.font = "24px Arial";
            ctx.textAlign = "center";
            ctx.fillText("ğŸ§", item.x + (item.cols*GRID_SIZE)/2, item.y + (item.rows*GRID_SIZE)/2);
        }

        function drawGameboy(ctx, item) {
            drawBaseShape(ctx, item);
            // ç•«è¢å¹•
            ctx.fillStyle = "#004d40";
            let cx = item.x + (item.cols*GRID_SIZE)/2;
            let cy = item.y + (item.rows*GRID_SIZE)/2;
            ctx.fillRect(cx - 15, cy - 15, 30, 20);
            // æŒ‰éˆ•
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(cx + 10, cy + 10, 4, 0, Math.PI*2);
            ctx.fill();
        }

        function drawPencilBox(ctx, item) {
            drawBaseShape(ctx, item);
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            // æ‹‰éŠç·š
            let cx = item.x + (item.cols*GRID_SIZE)/2;
            let cy = item.y + (item.rows*GRID_SIZE)/2;
            ctx.fillRect(item.x, cy-2, item.cols*GRID_SIZE, 4);
        }

        function drawEraser(ctx, item) {
            drawBaseShape(ctx, item);
            ctx.fillStyle = "white";
            // å¥—å­
            ctx.fillRect(item.x + 5, item.y + 5, GRID_SIZE - 10, GRID_SIZE - 20);
            ctx.fillStyle = "#333";
            ctx.font = "10px Arial";
            ctx.fillText("Pentel", item.x + GRID_SIZE/2, item.y + GRID_SIZE/2);
        }

        function drawTetris(ctx, item) {
            // ç•«å‡ºé¡ä¼¼ç©æœ¨çš„å‡¸èµ·æ„Ÿ
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        const dx = item.x + c * GRID_SIZE;
                        const dy = item.y + r * GRID_SIZE;
                        
                        ctx.fillStyle = item.color;
                        ctx.fillRect(dx, dy, GRID_SIZE, GRID_SIZE);
                        
                        // å…§åœˆäº®è‰²
                        ctx.fillStyle = "rgba(255,255,255,0.3)";
                        ctx.fillRect(dx+5, dy+5, GRID_SIZE-10, GRID_SIZE-10);
                        
                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                        ctx.strokeRect(dx, dy, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
        }

        // --- æ ¸å¿ƒé‚è¼¯ï¼šç”Ÿæˆå¯è§£æ‹¼åœ– (Algorithm) ---
        
        function createSolvablePuzzle() {
            items = [];
            // 1. å»ºç«‹ä¸€å€‹ç©ºçš„è™›æ“¬ç¶²æ ¼
            let grid = new Array(GRID_ROWS).fill(0).map(() => new Array(GRID_COLS).fill(0));
            
            // 2. å˜—è©¦å¡«æ»¿å®ƒ
            for(let r=0; r<GRID_ROWS; r++) {
                for(let c=0; c<GRID_COLS; c++) {
                    if(grid[r][c] === 0) {
                        // é€™å€‹ä½ç½®æ˜¯ç©ºçš„ï¼Œå˜—è©¦æ”¾å…¥ä¸€å€‹å½¢ç‹€
                        placeRandomShape(grid, r, c);
                    }
                }
            }
            
            // 3. å°‡ç”Ÿæˆçš„ç‰©å“ç§»åˆ°ç­‰å¾…å€ (æ‰“æ•£)
            items.forEach(item => {
                // éš¨æ©Ÿä½ç½®åœ¨å³å´
                item.x = BACKPACK_W + OFFSET_X + 40 + Math.random() * 50;
                item.y = 50 + Math.random() * 300;
                // éš¨æ©Ÿæ—‹è½‰å¹¾æ¬¡å¢åŠ é›£åº¦
                let rots = Math.floor(Math.random() * 4);
                for(let i=0; i<rots; i++) item.rotate();
            });
        }

        function placeRandomShape(grid, r, c) {
            // éš¨æ©Ÿæ‰“äº‚å½¢ç‹€å˜—è©¦é †åº
            let shapesToTry = [...SHAPES].sort(() => Math.random() - 0.5);
            
            for (let shape of shapesToTry) {
                // æª¢æŸ¥é€™å€‹å½¢ç‹€æ˜¯å¦èƒ½æ”¾å…¥ (r, c)
                if (canFit(grid, r, c, shape)) {
                    // æ±ºå®šé€™å€‹å½¢ç‹€æ˜¯ä»€éº¼ç‰©å“
                    let templateKey = assignTheme(shape);
                    
                    // å‰µå»ºç‰©å“ (å…ˆæ”¾åœ¨é‚è¼¯ä½ç½®ä¸Šï¼Œä¹‹å¾Œå†ç§»èµ°)
                    let item = new Item(shape, 0, 0, templateKey); // åº§æ¨™æš«æ™‚ä¸é‡è¦
                    items.push(item);
                    
                    // æ¨™è¨˜ç¶²æ ¼ç‚ºå·²ä½”ç”¨
                    markGrid(grid, r, c, shape, 1);
                    return;
                }
            }
            // å‡å¦‚éƒ½æ”¾ä¸ä¸‹ï¼Œç†è«–ä¸Š SHAPES è£¡æœ‰ [1] (1x1)ï¼Œæ‡‰è©²ç¸½æ˜¯èƒ½æ”¾ä¸‹çš„
        }

        function canFit(grid, r, c, shape) {
            let rows = shape.length;
            let cols = shape[0].length;
            
            if (r + rows > GRID_ROWS || c + cols > GRID_COLS) return false;
            
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1 && grid[r+i][c+j] === 1) {
                        return false; // é‡ç–Š
                    }
                }
            }
            return true;
        }

        function markGrid(grid, r, c, shape, val) {
            let rows = shape.length;
            let cols = shape[0].length;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1) {
                        grid[r+i][c+j] = val;
                    }
                }
            }
        }

        function assignTheme(shape) {
            // æ ¹æ“šå½¢ç‹€ç‰¹å¾µåˆ†é…å¤–è§€
            let area = 0;
            shape.flat().forEach(v => area += v);
            
            // ç°¡å–®è¦å‰‡
            if (area === 1) return 'eraser';
            if (shape.length === 1 || shape[0].length === 1) {
                if (area >= 3) return 'ruler'; // é•·æ¢
                return 'pencil_box';
            }
            // æª¢æŸ¥æ˜¯å¦æ˜¯å¯¦å¿ƒçŸ©å½¢
            let isRect = true;
            for(let row of shape) if(row.includes(0)) isRect = false;
            
            if (isRect) {
                if (area >= 4) return Math.random() > 0.5 ? 'book' : 'notebook';
                return 'tetris';
            }
            
            // ä¸è¦å‰‡
            let rand = Math.random();
            if (rand < 0.3) return 'headphones';
            if (rand < 0.6) return 'gameboy';
            return 'tetris';
        }


        // --- éŠæˆ²äº’å‹•é‚è¼¯ ---

        function checkCollision(currentItem, targetGridX, targetGridY) {
            // 1. é‚Šç•Œæª¢æŸ¥
             for(let r=0; r<currentItem.rows; r++) {
                for(let c=0; c<currentItem.cols; c++) {
                    if (currentItem.shape[r][c] === 1) {
                        let gx = targetGridX + c;
                        let gy = targetGridY + r;
                        if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return true;
                    }
                }
            }
            // 2. ç‰©å“é‡ç–Šæª¢æŸ¥
            for (let other of items) {
                if (other === currentItem || !other.isInside) continue;
                let otherGridX = Math.round((other.x - OFFSET_X) / GRID_SIZE);
                let otherGridY = Math.round((other.y - OFFSET_Y) / GRID_SIZE);
                
                for(let r=0; r<currentItem.rows; r++) {
                    for(let c=0; c<currentItem.cols; c++) {
                        if(currentItem.shape[r][c] === 1) {
                            let absX = targetGridX + c;
                            let absY = targetGridY + r;
                            // Check against other
                            let relX = absX - otherGridX;
                            let relY = absY - otherGridY;
                            if (relX >= 0 && relX < other.cols && relY >= 0 && relY < other.rows) {
                                if (other.shape[relY][relX] === 1) return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateStats() {
            let usedArea = 0;
            items.forEach(item => { if (item.isInside) usedArea += item.area; });
            let totalArea = GRID_COLS * GRID_ROWS;
            let percentage = Math.round((usedArea / totalArea) * 100);
            uiCoverage.innerText = percentage + "%";
            
            if (percentage === 100) {
                uiWinMsg.style.display = "block";
                uiFeedback.innerText = "ğŸ† å¤ªæ£’äº†ï¼ä½ æˆåŠŸå¡«æ»¿äº†èƒŒåŒ…ï¼";
                uiFeedback.style.color = "green";
                // æ…¶ç¥å‹•ç•« (ç°¡å–®éœ‡å‹•)
                if(navigator.vibrate) navigator.vibrate([100,50,100]);
            } else {
                uiWinMsg.style.display = "none";
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // èƒŒåŒ…åº•åœ–
            ctx.fillStyle = "#fff"; 
            ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // æ ¼ç·š
            ctx.strokeStyle = "#eeeeee";
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.moveTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y);
                ctx.lineTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y + BACKPACK_H);
            }
            for (let j = 0; j <= GRID_ROWS; j++) {
                ctx.moveTo(OFFSET_X, OFFSET_Y + j * GRID_SIZE);
                ctx.lineTo(OFFSET_X + BACKPACK_W, OFFSET_Y + j * GRID_SIZE);
            }
            ctx.stroke();
            
            ctx.strokeStyle = "#795548";
            ctx.lineWidth = 3;
            ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            ctx.fillStyle = "#8d6e63";
            ctx.font = "16px Arial";
            ctx.fillText(`èƒŒåŒ…å®¹é‡: ${GRID_COLS} x ${GRID_ROWS} = 80`, OFFSET_X, OFFSET_Y - 10);
            ctx.fillText("ğŸ“¦ ç‰©å“å€", BACKPACK_W + OFFSET_X + 40, OFFSET_Y - 10);

            // ç¹ªè£½æ‰€æœ‰ç‰©å“
            items.forEach(item => {
                if (item !== draggedItem) item.draw(ctx);
            });
            
            if (draggedItem) {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 10;
                draggedItem.draw(ctx);
                ctx.restore();
            }
        }

        // --- è¼¸å…¥äº‹ä»¶ ---
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getPointerPos(e);
            const currentTime = new Date().getTime();

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (item.hitTest(pos.x, pos.y)) {
                    
                    // æª¢æ¸¬é›™æ“Š (Double Click) é€²è¡Œæ—‹è½‰
                    // å¦‚æœé»æ“Šé–“éš” < 300ms ä¸”é»çš„æ˜¯åŒä¸€å€‹ç‰©å“ (æˆ–å‰›é¸ä¸­)
                    if (currentTime - lastClickTime < 300) {
                         item.rotate();
                         // æ—‹è½‰å¾Œå¦‚æœå¡ä½ï¼Œç°¡å–®è™•ç†ï¼šä¸ç§»å‹•ï¼Œè®“ç©å®¶è‡ªå·±ç§»é–‹
                         uiFeedback.innerText = "ğŸ”„ å·²æ—‹è½‰ï¼";
                         uiFeedback.style.color = "blue";
                         draw();
                         lastClickTime = 0;
                         return;
                    }
                    lastClickTime = currentTime;

                    draggedItem = item;
                    dragOffsetX = pos.x - item.x;
                    dragOffsetY = pos.y - item.y;
                    
                    items.splice(i, 1);
                    items.push(item);

                    uiItemInfo.innerHTML = `
                        <strong>${item.template.name}</strong><br>
                        ä½”åœ°é¢ç©ï¼š${item.area} æ ¼<br>
                        <span style="color:#666; font-size:0.9em">é»æ“Šå…©ä¸‹å¯æ—‹è½‰</span>
                    `;
                    uiFeedback.innerText = `ç§»å‹•ï¼š${item.template.name}`;
                    uiFeedback.style.color = "#555";
                    
                    draw();
                    return;
                }
            }
        }

        function handleMove(e) {
            if (draggedItem) {
                if (e.type === 'touchmove') e.preventDefault();
                const pos = getPointerPos(e);
                draggedItem.x = pos.x - dragOffsetX;
                draggedItem.y = pos.y - dragOffsetY;
                draw();
            }
        }

        function handleEnd(e) {
            if (draggedItem) {
                const gridX = Math.round((draggedItem.x - OFFSET_X) / GRID_SIZE);
                const gridY = Math.round((draggedItem.y - OFFSET_Y) / GRID_SIZE);

                if (!checkCollision(draggedItem, gridX, gridY)) {
                    draggedItem.x = OFFSET_X + gridX * GRID_SIZE;
                    draggedItem.y = OFFSET_Y + gridY * GRID_SIZE;
                    draggedItem.isInside = true;
                    uiFeedback.innerText = "âœ… æ”¾ç½®æˆåŠŸ";
                    uiFeedback.style.color = "green";
                    if(navigator.vibrate) navigator.vibrate(20);
                } else {
                    draggedItem.isInside = false;
                    uiFeedback.innerText = "â›” é€™è£¡æ”¾ä¸ä¸‹ï¼è©¦è©¦çœ‹æ—‹è½‰ï¼Ÿ";
                    uiFeedback.style.color = "red";
                }
                updateStats();
                draggedItem = null;
                draw();
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('btn-new-game').addEventListener('click', () => {
            createSolvablePuzzle();
            updateStats();
            draw();
            uiFeedback.innerText = "æ–°æŒ‘æˆ°é–‹å§‹ï¼";
        });
        
        document.getElementById('btn-hint').addEventListener('click', () => {
            uiFeedback.innerText = "ğŸ’¡ æç¤ºï¼šå¿«é€Ÿé»æ“Šç‰©å“å…©ä¸‹å¯ä»¥æ—‹è½‰å–”ï¼";
            uiFeedback.style.color = "#ffa000";
        });

        // åˆå§‹åŒ–
        createSolvablePuzzle();
        draw();

    </script>
</body>
</html>
