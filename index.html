<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šå…¨è¢å¹•è‡ªé©æ‡‰ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: #fff8e1;
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            touch-action: none;
            user-select: none;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* é ‚éƒ¨å„€è¡¨æ¿ */
        .dashboard {
            flex: 0 0 50px; /* å›ºå®šé«˜åº¦ */
            width: 95%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 5px 15px;
            box-sizing: border-box;
            border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-bottom: 3px solid #ffb74d;
            z-index: 10;
        }
        
        .stat-group {
            font-size: clamp(14px, 2vw, 18px); /* å­—é«”éš¨è¢å¹•ç¸®æ”¾ */
            font-weight: bold;
            color: #5d4037;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 6px 14px;
            font-size: clamp(12px, 1.5vw, 16px);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new { background-color: #66bb6a; }
        #btn-hint { background-color: #ffa726; }

        #math-feedback {
            flex: 0 0 30px;
            font-size: clamp(14px, 2vw, 20px);
            color: #5d4037;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-top: 5px;
        }

        /* éŠæˆ²å®¹å™¨ */
        .game-container {
            flex: 1; /* ä½”æ»¿å‰©é¤˜ç©ºé–“ */
            width: 98%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
        }

        canvas {
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-radius: 12px;
            background: #eceff1;
            touch-action: none;
        }

    </style>
</head>
<body>

    <div class="dashboard">
        <div class="stat-group">
            <div>ğŸ¯ ç›®æ¨™: 80æ ¼</div>
            <div>ğŸ“Š é€²åº¦: <span id="coverage" style="color:#d81b60">0%</span></div>
        </div>
        <div style="display:flex; gap:10px;">
            <button id="btn-hint">ğŸ’¡ æç¤º</button>
            <button id="btn-new">ğŸ”„ é‡ä¾†</button>
        </div>
    </div>

    <div id="math-feedback">æ­¡è¿æŒ‘æˆ°ï¼æ‹–æ›³ç‰©å“å¡«æ»¿èƒŒåŒ…</div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiFeedback = document.getElementById('math-feedback');

        // --- éŠæˆ²å¸¸æ•¸ ---
        const COLS_BACKPACK = 10;
        const ROWS_BACKPACK = 8;
        const COLS_GAP = 1; // èƒŒåŒ…èˆ‡ç‰©å“å€çš„é–“éš”
        const COLS_SPAWN = 4; // ç‰©å“å€å¯¬åº¦ (æ ¼)
        
        // ç¸½é‚è¼¯å¯¬åº¦ (èƒŒåŒ… + é–“éš” + ç‰©å“å€)
        const TOTAL_LOGICAL_COLS = COLS_BACKPACK + COLS_GAP + COLS_SPAWN;
        const TOTAL_LOGICAL_ROWS = ROWS_BACKPACK;

        // --- è®Šæ•¸ (éš¨ RWD æ”¹è®Š) ---
        let GRID_SIZE = 40; // åˆå§‹å€¼ï¼Œæœƒè¢« resize è¦†è“‹
        let OFFSET_X = 20;
        let OFFSET_Y = 20;
        
        // å€åŸŸé‚Šç•Œ
        let BACKPACK_W = 0;
        let BACKPACK_H = 0;
        let SPAWN_X = 0;

        let items = [];
        let draggedItem = null;
        let dragOffsetGridX = 0; // ç´€éŒ„æ‹–æ›³æ™‚ï¼Œæ‰‹æŒ‡ç›¸å°æ–¼ç‰©å“å·¦ä¸Šè§’çš„ã€Œæ ¼å­ã€åç§»é‡
        let dragOffsetGridY = 0;
        let lastClickTime = 0;

        // --- ç‰©å“èˆ‡å½¢ç‹€ ---
        const ITEM_TEMPLATES = {
            'ruler': { name: "é•·å°º", color: '#fdd835', draw: drawRuler },
            'book': { name: "èª²æœ¬", color: '#42a5f5', draw: drawBook },
            'notebook': { name: "ç­†è¨˜æœ¬", color: '#66bb6a', draw: drawNotebook },
            'pencil_box': { name: "é‰›ç­†ç›’", color: '#ef5350', draw: drawPencilBox },
            'eraser': { name: "æ©¡çš®æ“¦", color: '#eceff1', draw: drawEraser },
            'headphones': { name: "è€³æ©Ÿ", color: '#ab47bc', draw: drawHeadphones },
            'gameboy': { name: "éŠæˆ²æ©Ÿ", color: '#26c6da', draw: drawGameboy },
            'tetris': { name: "ç©æœ¨", color: '#ff7043', draw: drawTetris }
        };

        const SHAPES = [
            [[1,1,1,1]], // 1x4
            [[1,1,1],[1,0,0]], // L
            [[1,1],[1,1]], // 2x2
            [[1,1,1],[0,1,0]], // T
            [[1,1],[1,0],[1,0]], // Long L
            [[1,1,1]], // 1x3
            [[1,1]], // 1x2
            [[1]] // 1x1
        ];

        class Item {
            constructor(shape, logicalX, logicalY, templateKey) {
                this.shape = shape;
                this.logicalX = logicalX; // é‚è¼¯åº§æ¨™ (æ ¼å­å–®ä½ï¼Œå¯èƒ½ç‚ºå°æ•¸)
                this.logicalY = logicalY;
                this.template = ITEM_TEMPLATES[templateKey];
                this.color = this.template.color;
                this.isInside = false;
                this.updateDimensions();
            }

            updateDimensions() {
                this.rows = this.shape.length;
                this.cols = this.shape[0].length;
                this.area = 0;
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.shape[r][c] === 1) this.area++;
                    }
                }
            }

            rotate() {
                const newRows = this.cols;
                const newCols = this.rows;
                let newShape = new Array(newRows).fill(0).map(() => new Array(newCols).fill(0));
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        newShape[c][this.rows - 1 - r] = this.shape[r][c];
                    }
                }
                this.shape = newShape;
                this.updateDimensions();
            }

            draw(ctx) {
                // å°‡é‚è¼¯åº§æ¨™è½‰æ›ç‚ºåƒç´ åº§æ¨™é€²è¡Œç¹ªè£½
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                
                if (this.template.draw) {
                    this.template.draw(ctx, px, py, this);
                }
            }

            hitTest(mx, my) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                
                // å¯¬é¬†åˆ¤å®š (Bounding Box)
                if (mx < px || mx > px + this.cols * GRID_SIZE ||
                    my < py || my > py + this.rows * GRID_SIZE) return false;

                // ç²¾ç¢ºåˆ¤å®š (æ ¼å…§)
                const col = Math.floor((mx - px) / GRID_SIZE);
                const row = Math.floor((my - py) / GRID_SIZE);
                
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    return this.shape[row][col] === 1;
                }
                return false;
            }
        }

        // --- ç¹ªåœ– Helper ---
        function drawBaseBlock(ctx, x, y, color, size) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, size, size);
            // ç°¡å–®ç«‹é«”æ„Ÿ
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(x, y, size, size * 0.1);
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(x, y + size * 0.9, size, size * 0.1);
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.strokeRect(x, y, size, size);
        }

        function iterateShape(item, startX, startY, callback) {
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c] === 1) {
                        callback(startX + c * GRID_SIZE, startY + r * GRID_SIZE, r, c);
                    }
                }
            }
        }

        // --- å…·é«”ç‰©å“ç¹ªè£½ (éƒ½ä¾è³´ GRID_SIZE) ---
        function drawRuler(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.strokeStyle = "#5d4037";
                ctx.lineWidth = Math.max(1, GRID_SIZE * 0.05);
                ctx.beginPath();
                const gs = GRID_SIZE;
                ctx.moveTo(x + gs*0.25, y); ctx.lineTo(x + gs*0.25, y + gs*0.25);
                ctx.moveTo(x + gs*0.5, y); ctx.lineTo(x + gs*0.5, y + gs*0.4);
                ctx.moveTo(x + gs*0.75, y); ctx.lineTo(x + gs*0.75, y + gs*0.25);
                ctx.stroke();
            });
        }

        function drawEraser(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y, r, c) => {
                // ç™½åº•
                ctx.fillStyle = "#f5f5f5";
                ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                // è—å¥—
                ctx.fillStyle = "#1e88e5";
                const sleeveH = GRID_SIZE * 0.6;
                ctx.fillRect(x+2, y + GRID_SIZE - sleeveH - 2, GRID_SIZE-4, sleeveH);
                ctx.strokeStyle = "#ccc";
                ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
            });
        }

        function drawGameboy(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y, r, c) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                // è¢å¹•
                const m = GRID_SIZE * 0.15;
                ctx.fillStyle = "#004d40";
                ctx.fillRect(x+m, y+m, GRID_SIZE-m*2, GRID_SIZE*0.4);
                // æŒ‰éˆ•
                ctx.fillStyle = "#d32f2f";
                ctx.beginPath();
                ctx.arc(x + GRID_SIZE*0.8, y + GRID_SIZE*0.75, GRID_SIZE*0.1, 0, Math.PI*2);
                ctx.fill();
            });
        }
        
        // å…¶ä»–ç°¡å–®ç¹ªè£½
        function drawBook(ctx, px, py, item) {
            iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.fillRect(x + GRID_SIZE*0.1, y, GRID_SIZE*0.15, GRID_SIZE);
            });
        }
        function drawNotebook(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y, r) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                if(r===0) {
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.arc(x+GRID_SIZE*0.3, y+GRID_SIZE*0.1, GRID_SIZE*0.08, 0, Math.PI*2);
                    ctx.arc(x+GRID_SIZE*0.7, y+GRID_SIZE*0.1, GRID_SIZE*0.08, 0, Math.PI*2);
                    ctx.fill();
                }
            });
        }
        function drawPencilBox(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillRect(x, y+GRID_SIZE*0.45, GRID_SIZE, GRID_SIZE*0.1);
            });
        }
        function drawHeadphones(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.font = `${GRID_SIZE*0.5}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillText("ğŸ§", x+GRID_SIZE/2, y+GRID_SIZE/2);
            });
        }
        function drawTetris(ctx, px, py, item) {
             iterateShape(item, px, py, (x, y) => {
                drawBaseBlock(ctx, x, y, item.color, GRID_SIZE);
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.strokeRect(x+GRID_SIZE*0.1, y+GRID_SIZE*0.1, GRID_SIZE*0.8, GRID_SIZE*0.8);
            });
        }


        // --- è‡ªé©æ‡‰æ ¸å¿ƒ (RWD Logic) ---
        function resizeGame() {
            // 1. å–å¾—å¯ç”¨çš„å®¹å™¨å¤§å°
            const container = document.querySelector('.game-container');
            const availW = container.clientWidth;
            const availH = container.clientHeight;

            // 2. è¨ˆç®—æœ€ä½³ GRID_SIZE
            // æˆ‘å€‘å¸Œæœ›é¡¯ç¤º TOTAL_LOGICAL_COLS å’Œ TOTAL_LOGICAL_ROWS
            // ä¸”è¦ç•™ä¸€äº›é‚Šè· (Margin)
            const margin = 20; // px
            const safeW = availW - margin * 2;
            const safeH = availH - margin * 2;

            const sizeByW = safeW / TOTAL_LOGICAL_COLS;
            const sizeByH = safeH / TOTAL_LOGICAL_ROWS;

            // å–æœ€å°å€¼ï¼Œç¢ºä¿å®Œå…¨æ”¾å…¥
            GRID_SIZE = Math.floor(Math.min(sizeByW, sizeByH));
            
            // 3. è¨­å®š Canvas å¯¦éš›å¤§å°
            canvas.width = safeW;
            canvas.height = safeH;
            
            // 4. è¨ˆç®—åç§»é‡ (è®“ç•«é¢ç½®ä¸­)
            // å¯¦éš›å…§å®¹å¯¬åº¦
            const contentW = TOTAL_LOGICAL_COLS * GRID_SIZE;
            const contentH = TOTAL_LOGICAL_ROWS * GRID_SIZE;
            
            OFFSET_X = Math.floor((safeW - contentW) / 2);
            OFFSET_Y = Math.floor((safeH - contentH) / 2);

            // æ›´æ–°å€åŸŸå¸¸æ•¸
            BACKPACK_W = COLS_BACKPACK * GRID_SIZE;
            BACKPACK_H = ROWS_BACKPACK * GRID_SIZE;
            SPAWN_X = OFFSET_X + (COLS_BACKPACK + COLS_GAP) * GRID_SIZE;

            draw();
        }

        // --- é‚è¼¯ï¼šç”Ÿæˆèˆ‡æ•£å¸ƒ ---
        function createSolvablePuzzle() {
            items = [];
            let grid = new Array(ROWS_BACKPACK).fill(0).map(() => new Array(COLS_BACKPACK).fill(0));
            
            // å¡«æ»¿ç¶²æ ¼
            for(let r=0; r<ROWS_BACKPACK; r++) {
                for(let c=0; c<COLS_BACKPACK; c++) {
                    if(grid[r][c] === 0) {
                        placeRandomShape(grid, r, c);
                    }
                }
            }
            
            // å°‡ç‰©å“æ•£å¸ƒåˆ°å³å´å€åŸŸ
            // ä½¿ç”¨ã€Œé‚è¼¯åº§æ¨™ã€ä¾†æ•£å¸ƒï¼Œç¢ºä¿ä¸æœƒå¤ªæ“ 
            let spawnCol = COLS_BACKPACK + COLS_GAP;
            let spawnRow = 0;

            items.forEach((item) => {
                item.isInside = false;
                
                // ç°¡å–®çš„æ’åˆ—é‚è¼¯ï¼šå¾€å³å´å †ç–Š
                // ç‚ºäº†é¿å…é‡ç–Šï¼Œæˆ‘å€‘çµ¦æ¯å€‹ç‰©å“ä¸€å€‹éš¨æ©Ÿçš„ç›®æ¨™æ ¼å­
                // ä½†è¦é™åˆ¶åœ¨ Spawn å€åŸŸå…§
                
                // X: åœ¨ Spawn å€åŸŸçš„ 0~3 æ ¼ä¹‹é–“
                let targetC = spawnCol + Math.random() * (COLS_SPAWN - item.cols);
                // Y: éš¨æ©Ÿåˆ†æ•£åœ¨é«˜åº¦å…§
                let targetR = Math.random() * (ROWS_BACKPACK - item.rows);

                // ä¿®æ­£ï¼šç‚ºäº†è®“ç‰©å“æ›´æ˜é¡¯ï¼Œæˆ‘å€‘ç”¨é¡ä¼¼ç€‘å¸ƒæµçš„æ–¹å¼ç¨å¾®éŒ¯é–‹
                item.logicalX = targetC;
                item.logicalY = targetR;

                // éš¨æ©Ÿæ—‹è½‰
                let rots = Math.floor(Math.random() * 4);
                for(let i=0; i<rots; i++) item.rotate();
                
                // æ—‹è½‰å¾Œå¯èƒ½è¶…å‡ºé‚Šç•Œï¼Œæ‹‰å›ä¾†
                if (item.logicalX + item.cols > TOTAL_LOGICAL_COLS) item.logicalX = TOTAL_LOGICAL_COLS - item.cols;
                if (item.logicalY + item.rows > TOTAL_LOGICAL_ROWS) item.logicalY = TOTAL_LOGICAL_ROWS - item.rows;
            });
        }

        function placeRandomShape(grid, r, c) {
            let shapesToTry = [...SHAPES].sort(() => Math.random() - 0.5);
            for (let shape of shapesToTry) {
                if (canFit(grid, r, c, shape)) {
                    let templateKey = assignTheme(shape);
                    let item = new Item(shape, 0, 0, templateKey); // åº§æ¨™ç¨å¾Œè¨­å®š
                    items.push(item);
                    markGrid(grid, r, c, shape, 1);
                    return;
                }
            }
        }

        function canFit(grid, r, c, shape) {
            let rows = shape.length;
            let cols = shape[0].length;
            if (r + rows > ROWS_BACKPACK || c + cols > COLS_BACKPACK) return false;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1 && grid[r+i][c+j] === 1) return false;
                }
            }
            return true;
        }

        function markGrid(grid, r, c, shape, val) {
            let rows = shape.length;
            let cols = shape[0].length;
            for(let i=0; i<rows; i++) {
                for(let j=0; j<cols; j++) {
                    if (shape[i][j] === 1) grid[r+i][c+j] = val;
                }
            }
        }

        function assignTheme(shape) {
            let area = 0;
            shape.flat().forEach(v => area += v);
            if (area === 1) return 'eraser';
            if (shape.length === 1 || shape[0].length === 1) {
                if (area >= 3) return 'ruler';
                return 'pencil_box';
            }
            let isRect = true;
            for(let row of shape) if(row.includes(0)) isRect = false;
            if (isRect) {
                if (area >= 4) return Math.random() > 0.5 ? 'book' : 'notebook';
                return 'tetris';
            }
            let rand = Math.random();
            if (rand < 0.3) return 'headphones';
            if (rand < 0.6) return 'gameboy';
            return 'tetris';
        }

        // --- äº’å‹•èˆ‡åˆ¤å®š ---
        function checkCollision(currentItem, targetCol, targetRow) {
            // 1. é‚Šç•Œåˆ¤å®š (åªèƒ½æ”¾åœ¨èƒŒåŒ…å€ 0~9)
            for(let r=0; r<currentItem.rows; r++) {
                for(let c=0; c<currentItem.cols; c++) {
                    if (currentItem.shape[r][c] === 1) {
                        let gc = targetCol + c;
                        let gr = targetRow + r;
                        if (gc < 0 || gc >= COLS_BACKPACK || gr < 0 || gr >= ROWS_BACKPACK) return true;
                    }
                }
            }
            // 2. é‡ç–Šåˆ¤å®š
            for (let other of items) {
                if (other === currentItem || !other.isInside) continue;
                
                // æ¯”å°é‚è¼¯åº§æ¨™ (éƒ½æ˜¯æ•´æ•¸)
                let otherCol = Math.round(other.logicalX);
                let otherRow = Math.round(other.logicalY);

                for(let r=0; r<currentItem.rows; r++) {
                    for(let c=0; c<currentItem.cols; c++) {
                        if(currentItem.shape[r][c] === 1) {
                            let absCol = targetCol + c;
                            let absRow = targetRow + r;
                            
                            let relCol = absCol - otherCol;
                            let relRow = absRow - otherRow;

                            if (relCol >= 0 && relCol < other.cols && relRow >= 0 && relRow < other.rows) {
                                if (other.shape[relRow][relCol] === 1) return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateStats() {
            let usedArea = 0;
            items.forEach(item => { if (item.isInside) usedArea += item.area; });
            let percentage = Math.round((usedArea / (COLS_BACKPACK * ROWS_BACKPACK)) * 100);
            uiCoverage.innerText = percentage + "%";
            if (percentage === 100) {
                uiFeedback.innerHTML = "ğŸ† <span style='color:green'>å®Œç¾ï¼æŒ‘æˆ°æˆåŠŸï¼</span>";
                if(navigator.vibrate) navigator.vibrate([100,50,100]);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ç¹ªè£½èƒŒåŒ…å€åŸŸ (å·¦å´)
            ctx.fillStyle = "white";
            ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // èƒŒåŒ…æ ¼ç·š
            ctx.strokeStyle = "#eee";
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= COLS_BACKPACK; i++) {
                ctx.moveTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y);
                ctx.lineTo(OFFSET_X + i * GRID_SIZE, OFFSET_Y + BACKPACK_H);
            }
            for (let j = 0; j <= ROWS_BACKPACK; j++) {
                ctx.moveTo(OFFSET_X, OFFSET_Y + j * GRID_SIZE);
                ctx.lineTo(OFFSET_X + BACKPACK_W, OFFSET_Y + j * GRID_SIZE);
            }
            ctx.stroke();
            
            // èƒŒåŒ…å¤–æ¡†
            ctx.strokeStyle = "#795548";
            ctx.lineWidth = 3;
            ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);

            // 2. ç¹ªè£½ç‰©å“å€èƒŒæ™¯ (å³å´)
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.roundRect(SPAWN_X, OFFSET_Y, COLS_SPAWN * GRID_SIZE, BACKPACK_H, 10);
            ctx.fill();
            
            ctx.fillStyle = "#8d6e63";
            ctx.font = `${GRID_SIZE*0.4}px Arial`;
            ctx.fillText("ğŸ“¦ ç‰©å“å€", SPAWN_X + 5, OFFSET_Y - 5);

            // 3. ç¹ªè£½ç‰©å“
            items.forEach(item => {
                if (item !== draggedItem) item.draw(ctx);
            });
            
            if (draggedItem) {
                ctx.save();
                ctx.shadowColor = "black";
                ctx.shadowBlur = 10;
                ctx.globalAlpha = 0.8;
                draggedItem.draw(ctx);
                ctx.restore();
            }
        }

        // --- äº‹ä»¶è™•ç† (çµ±ä¸€ Pointer Events) ---
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getPointerPos(e);
            const now = new Date().getTime();

            // å€’åºæª¢æ¸¬é»æ“Š
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                if (item.hitTest(pos.x, pos.y)) {
                    
                    // é›™æ“Šæ—‹è½‰
                    if (now - lastClickTime < 300) {
                        item.rotate();
                        uiFeedback.innerText = "ğŸ”„ å·²æ—‹è½‰";
                        draw();
                        lastClickTime = 0;
                        return;
                    }
                    lastClickTime = now;

                    draggedItem = item;
                    
                    // è¨ˆç®—é»æ“Šä½ç½®ç›¸å°æ–¼ç‰©å“å·¦ä¸Šè§’çš„åç§» (åƒç´ )
                    const itemPx = OFFSET_X + item.logicalX * GRID_SIZE;
                    const itemPy = OFFSET_Y + item.logicalY * GRID_SIZE;
                    
                    // è½‰æ›ç‚ºã€Œé‚è¼¯åç§»ã€ï¼Œè®“æ‹–æ›³æ™‚æ»‘é¼ ä¿æŒåœ¨é»æ“Šçš„é‚£ä¸€æ ¼
                    dragOffsetGridX = (pos.x - itemPx) / GRID_SIZE;
                    dragOffsetGridY = (pos.y - itemPy) / GRID_SIZE;

                    // ç§»åˆ°æœ€ä¸Šå±¤
                    items.splice(i, 1);
                    items.push(item);
                    
                    uiFeedback.innerText = `ç§»å‹•: ${item.template.name}`;
                    draw();
                    return;
                }
            }
        }

        function handleMove(e) {
            if (draggedItem) {
                if (e.type === 'touchmove') e.preventDefault();
                const pos = getPointerPos(e);
                
                // æ›´æ–°é‚è¼¯åº§æ¨™ (æ”¯æ´å°æ•¸ç§»å‹•)
                // å…¬å¼: æ–°çš„å·¦ä¸Šè§’ = (é¼ æ¨™ä½ç½® - åç§»é‡ - åŸé») / æ ¼å­å¤§å°
                draggedItem.logicalX = (pos.x / GRID_SIZE) - dragOffsetGridX - (OFFSET_X / GRID_SIZE);
                draggedItem.logicalY = (pos.y / GRID_SIZE) - dragOffsetGridY - (OFFSET_Y / GRID_SIZE);
                
                draw();
            }
        }

        function handleEnd(e) {
            if (draggedItem) {
                // å¸é™„åˆ°æœ€è¿‘çš„æ•´æ•¸æ ¼å­
                const snapCol = Math.round(draggedItem.logicalX);
                const snapRow = Math.round(draggedItem.logicalY);

                // ç¢°æ’æª¢æ¸¬ (å¿…é ˆå®Œå…¨åœ¨èƒŒåŒ…å…§)
                if (!checkCollision(draggedItem, snapCol, snapRow)) {
                    draggedItem.logicalX = snapCol;
                    draggedItem.logicalY = snapRow;
                    draggedItem.isInside = true;
                    uiFeedback.innerText = "âœ… æ”¾ç½®æˆåŠŸ";
                    if(navigator.vibrate) navigator.vibrate(30);
                } else {
                    // æ”¾ä¸ä¸‹ -> å½ˆå›ç‰©å“å€çš„ç©ºä½ (æˆ–åªæ˜¯é¡¯ç¤ºç´…è‰²)
                    // é€™è£¡ç‚ºäº†é«”é©—ï¼Œå¦‚æœæ”¾ä¸ä¸‹ï¼Œå°±è®“å®ƒåœåœ¨åŸè™•(è¦–è¦ºä¸Š)ä½†æ¨™è¨˜ç‚ºæœªæ”¾å…¥ï¼Œ
                    // æˆ–è€…ç¨å¾®å½ˆé–‹ã€‚ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘è®“å®ƒåœåœ¨ä½¿ç”¨è€…æ”¾é–‹çš„ä½ç½®ï¼Œä½†æ¨™ç¤ºç‚ºç´…è‰²(ä¸‹æ¬¡draw)
                    // é€™è£¡é¸æ“‡ï¼šç›´æ¥å¸é™„åˆ°é‚£å€‹ä½ç½®ï¼Œä½† isInside = false (ä¸è¨ˆåˆ†)
                    draggedItem.logicalX = snapCol; // é‚„æ˜¯è®“å®ƒå°é½Šæ ¼å­æ¯”è¼ƒå¥½çœ‹
                    draggedItem.logicalY = snapRow;
                    draggedItem.isInside = false;
                    uiFeedback.innerText = "â›” ä½ç½®ç„¡æ•ˆ (é‡ç–Šæˆ–å‡ºç•Œ)";
                }
                updateStats();
                draggedItem = null;
                draw();
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        document.getElementById('btn-new').addEventListener('click', () => {
            createSolvablePuzzle();
            updateStats();
            draw();
            uiFeedback.innerText = "æ–°é—œå¡é–‹å§‹ï¼";
        });
        
        document.getElementById('btn-hint').addEventListener('click', () => {
            uiFeedback.innerHTML = "ğŸ’¡ æç¤ºï¼šå¿«é€Ÿé»æ“Šç‰©å“<b>å…©ä¸‹</b>å¯ä»¥æ—‹è½‰ï¼";
        });

        // ç›£è½è¦–çª—å¤§å°æ”¹è®Š
        window.addEventListener('resize', resizeGame);

        // åˆå§‹åŒ–
        createSolvablePuzzle();
        // å»¶é²ä¸€ä¸‹ç¢ºä¿ CSS layout å®Œæˆ
        setTimeout(resizeGame, 50);

    </script>
</body>
</html>
