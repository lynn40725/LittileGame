<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«ï¼šæœ€çµ‚æ˜“è®€ç‰ˆ</title>
    <style>
        /* å®šç¾©è®Šæ•¸ï¼šæ–¹ä¾¿èª¿æ•´é ‚éƒ¨é«˜åº¦ */
        :root {
            --header-height: 60px;
            --feedback-height: 30px;
        }
        
        /* å¼·åˆ¶é–å®šå…¨è¢å¹•ï¼Œé˜²æ­¢ iOS Safari çš„å½ˆæ€§æ²å‹• */
        html, body {
            width: 100%;
            height: 100%; 
            height: 100dvh; /* é‡å° iOS çš„å‹•æ…‹é«˜åº¦å–®ä½ */
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            background-color: #fff8e1; /* ç±³é»ƒè‰²èƒŒæ™¯ */
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
            position: fixed; /* é–å®šä½ç½® */
            display: flex;
            flex-direction: column;
        }
        
        /* 1. é ‚éƒ¨å„€è¡¨æ¿ */
        .dashboard {
            flex: 0 0 var(--header-height);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 0 10px;
            box-sizing: border-box; /* ç¢ºä¿ padding ä¸æœƒæ’å¤§å¯¬åº¦ */
            border-bottom: 3px solid #ffb74d;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* 2. ä¸‹æ–¹æ–‡å­—å›é¥‹å€ */
        #math-feedback {
            flex: 0 0 var(--feedback-height);
            font-size: 15px;
            color: #5d4037;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff8e1;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
        }

        /* 3. éŠæˆ²ä¸»ç•«é¢å®¹å™¨ (è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“) */
        .game-container {
            flex: 1; 
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 5px;
            box-sizing: border-box;
        }

        canvas {
            border-radius: 12px;
            background: #eceff1; /* ç•«å¸ƒèƒŒæ™¯è‰² */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        /* UI å…ƒä»¶æ¨£å¼ */
        .stat-group { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            font-size: 14px; 
            font-weight: bold; 
            color: #5d4037;
        }
        
        /* è—è‰²çš„å–®ä½é¡¯ç¤ºæ¨™ç±¤ */
        .unit-badge { 
            background: #e1f5fe; 
            color: #0277bd; 
            padding: 4px 8px; 
            border-radius: 6px; 
            border: 1px solid #0277bd; 
            white-space: nowrap;
        }
        
        /* æ©˜è‰²çš„æ“ä½œèªªæ˜æ¨™ç±¤ */
        .instruction-tag {
            background: #fff3e0;
            color: #ef6c00;
            border: 2px dashed #ffb74d;
            padding: 5px 10px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 15px;
            display: flex;
            align-items: center;
            white-space: nowrap;
            animation: pulse 2s infinite; /* å‘¼å¸ç‡ˆå‹•ç•« */
        }
        
        /* æŒ‰éˆ•æ¨£å¼ */
        button { 
            padding: 8px 14px; 
            font-size: 14px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: bold; 
            color: white; 
            box-shadow: 0 2px 0 rgba(0,0,0,0.2); 
            white-space: nowrap;
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new { background-color: #66bb6a; }

        /* å‹•ç•«é—œéµå½±æ ¼ */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* å½ˆå‡ºè¦–çª— (Modal) æ¨£å¼ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; /* é è¨­éš±è— */
            justify-content: center; align-items: center; z-index: 100;
            backdrop-filter: blur(2px);
        }
        .modal-box {
            background: white; padding: 20px; border-radius: 15px;
            text-align: center; width: 320px; border: 4px solid #ffb74d;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        .modal-title { font-size: 22px; color: #d81b60; margin-bottom: 10px; font-weight: bold; }
        .modal-question { font-size: 18px; color: #333; margin-bottom: 15px; line-height: 1.6; }
        .modal-input { font-size: 24px; padding: 5px; width: 100px; text-align: center; border: 2px solid #ccc; border-radius: 8px; margin-bottom: 15px; }
        .modal-btn { padding: 10px 24px; font-size: 18px; border-radius: 8px; border: none; cursor: pointer; color: white; background: #1e88e5; }

    </style>
</head>
<body>

    <div class="dashboard">
        <div class="stat-group">
            <div class="unit-badge">ğŸ“ é‚Šé•·: <span id="unit-len">1</span></div>
            <div><span id="coverage" style="color:#d81b60">0%</span></div>
        </div>

        <div class="instruction-tag">ğŸ‘† é»å…©ä¸‹æ—‹è½‰</div>

        <div>
            <button id="btn-new">ğŸ”„ é‡ä¾†</button>
        </div>
    </div>

    <div id="math-feedback">æ‹–æ›³ç©æœ¨å¡«æ»¿èƒŒåŒ… | ç­”å°é¢ç©å¯ç²å¾—ä¸‰æ¬¡æ©Ÿæœƒ</div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="modal-overlay" id="quiz-modal">
        <div class="modal-box">
            <div class="modal-title">ğŸ§  é¢ç©å¤§æŒ‘æˆ°</div>
            <div class="modal-question" id="quiz-text"></div>
            <input type="number" class="modal-input" id="quiz-input" placeholder="?">
            <br>
            <button class="modal-btn" id="btn-quiz-submit">é€å‡ºç­”æ¡ˆ</button>
        </div>
    </div>

    <script>
        // --- è®Šæ•¸å®£å‘Šèˆ‡è¨­å®š ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiFeedback = document.getElementById('math-feedback');
        const uiUnitLen = document.getElementById('unit-len');
        
        // Modal ç›¸é—œå…ƒç´ 
        const modal = document.getElementById('quiz-modal');
        const quizText = document.getElementById('quiz-text');
        const quizInput = document.getElementById('quiz-input');
        const quizSubmit = document.getElementById('btn-quiz-submit');

        // éŠæˆ²å¸¸æ•¸è¨­å®š
        const COLS_BACKPACK = 10; // èƒŒåŒ…å¯¬åº¦ (æ ¼)
        const ROWS_BACKPACK = 8;  // èƒŒåŒ…é«˜åº¦ (æ ¼)
        const COLS_GAP = 1;       // ä¸­é–“é–“éš” (æ ¼)
        const COLS_SPAWN = 4;     // å³å´ç‰©å“å€å¯¬åº¦ (æ ¼)
        
        // ç¸½é‚è¼¯å¯¬åº¦ = èƒŒåŒ… + é–“éš” + ç‰©å“å€
        const TOTAL_LOGICAL_COLS = COLS_BACKPACK + COLS_GAP + COLS_SPAWN;
        const TOTAL_LOGICAL_ROWS = ROWS_BACKPACK;

        // ç•«é¢ç›¸é—œè®Šæ•¸ (æœƒéš¨ RWD æ”¹è®Š)
        let GRID_SIZE = 40;
        let OFFSET_X = 0;
        let OFFSET_Y = 0;
        let BACKPACK_W, BACKPACK_H;

        // æ•¸å­¸é‚è¼¯è®Šæ•¸
        let UNIT_LENGTH = 1; // ç•¶å‰é‚Šé•·
        const POSSIBLE_LENGTHS = [1, 2, 3, 4, 5, 10]; // å¯èƒ½å‡ºç¾çš„é‚Šé•·
        let unlockStatus = {}; // è¨˜éŒ„æ¯å€‹ç‰©å“çš„è§£é–å‰©é¤˜æ¬¡æ•¸
        
        // ç­”é¡Œæš«å­˜è®Šæ•¸
        let pendingItem = null;
        let pendingCol = 0, pendingRow = 0;
        let originalPos = {x:0, y:0}; // ç­”éŒ¯æ™‚å½ˆå›çš„ä½ç½®

        // ç‰©å“ç®¡ç†
        let items = [];
        let draggedItem = null;
        let dragOffsetGridX = 0;
        let dragOffsetGridY = 0;
        let lastClickTime = 0; // ç”¨æ–¼åˆ¤æ–·é›™æ“Š

        // --- å®šç¾©ç‰©å“å½¢ç‹€èˆ‡ç¹ªåœ–å‡½å¼ ---
        const SHAPES = [
            [[1,1,1,1]],            // 1x4 é•·æ¢
            [[1,1,1],[1,0,0]],      // L å‹
            [[1,1],[1,1]],          // 2x2 æ­£æ–¹
            [[1,1,1],[0,1,0]],      // T å‹
            [[1,1],[1,0],[1,0]],    // é•· L å‹
            [[1,1,1]],              // 1x3 é•·æ¢
            [[1,1]],                // 1x2 é•·æ¢
            [[1]]                   // 1x1 å–®æ ¼
        ];

        // --- ç‰©å“é¡åˆ¥ (Class Item) ---
        class Item {
            constructor(shape, key) {
                this.shape = shape;
                this.key = key;
                this.template = ITEM_TEMPLATES[key];
                this.color = this.template.color;
                this.logicalX = 0; 
                this.logicalY = 0;
                this.isInside = false;
                this.updateDim();
            }

            // æ›´æ–°ç‰©å“å°ºå¯¸ (è¡Œæ•¸ã€åˆ—æ•¸ã€é¢ç©)
            updateDim() {
                this.rows = this.shape.length; 
                this.cols = this.shape[0].length;
                this.area = 0; 
                this.shape.flat().forEach(v => this.area += v);
            }

            // æ—‹è½‰çŸ©é™£
            rotate() {
                let newShape = new Array(this.cols).fill(0).map(()=>new Array(this.rows).fill(0));
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        newShape[c][this.rows-1-r] = this.shape[r][c];
                    }
                }
                this.shape = newShape; 
                this.updateDim();
            }

            // ç¹ªè£½è‡ªå·±
            draw(ctx) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                
                // å‘¼å«å°æ‡‰çš„æ¨£æ¿ç¹ªåœ–å‡½å¼
                if(this.template.draw) {
                    this.template.draw(ctx, px, py, this);
                }
                
                // å¦‚æœæœªè§£é–ï¼Œä¸”ä¸åœ¨èƒŒåŒ…å…§ï¼Œé¡¯ç¤ºé–é ­åœ–ç¤º
                if(unlockStatus[this.key] <= 0 && !this.isInside && draggedItem !== this) {
                    ctx.fillStyle = "rgba(0,0,0,0.4)";
                    ctx.font = `${GRID_SIZE/2}px Arial`;
                    ctx.textAlign = "center";
                    ctx.fillText("ğŸ”’", px + GRID_SIZE/2, py + GRID_SIZE/2 + 5);
                }
            }

            // é»æ“Šæª¢æ¸¬
            hitTest(mx, my) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                
                // å…ˆæª¢æŸ¥å¤–æ¡† (Bounding Box)
                if(mx < px || mx > px + this.cols*GRID_SIZE || my < py || my > py + this.rows*GRID_SIZE) return false;
                
                // å†æª¢æŸ¥å…§éƒ¨æ ¼å­
                let c = Math.floor((mx-px)/GRID_SIZE);
                let r = Math.floor((my-py)/GRID_SIZE);
                return (r>=0 && r<this.rows && c>=0 && c<this.cols && this.shape[r][c]===1);
            }
        }

        // --- ç¹ªåœ– Helper (ç•«æ–¹å¡ŠåŸºç¤) ---
        function drawBase(ctx, x, y, color, size) { 
            ctx.fillStyle = color; 
            ctx.fillRect(x, y, size, size); 
            
            // ç°¡å–®çš„å…‰å½±æ•ˆæœ
            ctx.fillStyle = "rgba(255,255,255,0.3)"; 
            ctx.fillRect(x, y, size, size*0.2); // ä¸Šæ–¹é«˜å…‰
            ctx.strokeStyle = "rgba(0,0,0,0.1)"; 
            ctx.strokeRect(x, y, size, size);   // é‚Šæ¡†
        }

        // éæ­·å½¢ç‹€çš„æ¯å€‹æ ¼å­ï¼ŒåŸ·è¡Œç¹ªåœ–å‹•ä½œ
        function iter(item, px, py, callback) {
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c]) {
                        callback(px + c * GRID_SIZE, py + r * GRID_SIZE, r, c);
                    }
                }
            }
        }

        // --- ç‰©å“å¤–è§€å®šç¾© (æ¨£æ¿) ---
        // é€™è£¡å®šç¾©äº†æ¯å€‹ç‰©å“çš„é¡è‰²å’Œå°ˆå±¬ç¹ªåœ–å‡½å¼
        const ITEM_TEMPLATES = {
            'ruler': { 
                color: '#fdd835', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.strokeStyle="#5d4037"; ctx.beginPath(); 
                        ctx.moveTo(x+GRID_SIZE/2, y); ctx.lineTo(x+GRID_SIZE/2, y+GRID_SIZE/2); 
                        ctx.stroke(); 
                    }); 
                }
            },
            'book': { 
                color: '#42a5f5', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.fillStyle="rgba(255,255,255,0.4)"; 
                        ctx.fillRect(x+3, y, 3, GRID_SIZE); // æ›¸è„Š
                    }); 
                }
            },
            'notebook': { 
                color: '#66bb6a', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y, r) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        if(r===0){ // èºæ—‹å­”åªç•«åœ¨ç¬¬ä¸€æ’
                            ctx.fillStyle="#333"; ctx.beginPath(); 
                            ctx.arc(x+GRID_SIZE/2, y+4, 2, 0, 6.28); ctx.fill();
                        } 
                    }); 
                }
            },
            'pencil_box': { 
                color: '#ef5350', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.fillStyle="rgba(0,0,0,0.2)"; 
                        ctx.fillRect(x, y+GRID_SIZE/2-2, GRID_SIZE, 4); // æ‹‰éŠ
                    }); 
                }
            },
            'eraser': { 
                color: '#eceff1', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        ctx.fillStyle="#fff"; ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE); 
                        ctx.fillStyle="#1976d2"; ctx.fillRect(x+2, y+GRID_SIZE/2, GRID_SIZE-4, GRID_SIZE/2-2); // è—å¥—
                        ctx.strokeStyle="#ccc"; ctx.strokeRect(x, y, GRID_SIZE, GRID_SIZE); 
                    }); 
                }
            },
            'headphones': { 
                color: '#ab47bc', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.fillStyle="rgba(0,0,0,0.4)"; 
                        ctx.font=`${GRID_SIZE/2}px Arial`; ctx.textAlign="center"; 
                        ctx.fillText("ğŸ§", x+GRID_SIZE/2, y+GRID_SIZE*0.7); 
                    }); 
                }
            },
            'gameboy': { 
                color: '#26c6da', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.fillStyle="#004d40"; ctx.fillRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE*0.4); // è¢å¹•
                        ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(x+GRID_SIZE*0.8, y+GRID_SIZE*0.8, 3, 0, 6.28); ctx.fill(); // æŒ‰éˆ•
                    }); 
                }
            },
            'tetris': { 
                color: '#ff7043', 
                draw: (ctx, px, py, it) => { 
                    iter(it, px, py, (x, y) => { 
                        drawBase(ctx, x, y, it.color, GRID_SIZE); 
                        ctx.strokeStyle="white"; ctx.strokeRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE-8); 
                    }); 
                }
            }
        };

        // --- RWD æ ¸å¿ƒå‡½å¼ (è§£æ±º iPad åˆ‡åˆ°å•é¡Œ) ---
        function resizeGame() {
            // 1. å–å¾—ã€ŒéŠæˆ²å®¹å™¨ã€çš„çœŸå¯¦åƒç´ å¤§å°
            const container = document.querySelector('.game-container');
            const cW = container.clientWidth;
            const cH = container.clientHeight;

            // 2. è¨ˆç®—æ ¼å­å¤§å° (ä¿ç•™ 10px é‚Šè·)
            const padding = 10;
            const safeW = cW - padding * 2;
            const safeH = cH - padding * 2;

            // è¨ˆç®—å¯¬é«˜æ¯”ï¼Œå–æœ€å°å€¼ä»¥ç¢ºä¿å®Œå…¨æ”¾å…¥è¢å¹•
            const sW = safeW / TOTAL_LOGICAL_COLS;
            const sH = safeH / TOTAL_LOGICAL_ROWS;
            GRID_SIZE = Math.floor(Math.min(sW, sH));
            
            // 3. è¨­å®š Canvas å¯¦éš›å¤§å°
            canvas.width = cW;
            canvas.height = cH;

            // 4. è¨ˆç®—ç½®ä¸­åç§»é‡
            const contentW = TOTAL_LOGICAL_COLS * GRID_SIZE;
            const contentH = TOTAL_LOGICAL_ROWS * GRID_SIZE;
            
            OFFSET_X = Math.floor((cW - contentW) / 2);
            OFFSET_Y = Math.floor((cH - contentH) / 2);

            // æ›´æ–°å€åŸŸå°ºå¯¸
            BACKPACK_W = COLS_BACKPACK * GRID_SIZE;
            BACKPACK_H = ROWS_BACKPACK * GRID_SIZE;
            
            draw();
        }

        // --- éŠæˆ²åˆå§‹åŒ–é‚è¼¯ ---
        function initGame() {
            // 1. éš¨æ©Ÿæ±ºå®šæœ¬å±€é‚Šé•·
            UNIT_LENGTH = POSSIBLE_LENGTHS[Math.floor(Math.random() * POSSIBLE_LENGTHS.length)];
            uiUnitLen.innerText = UNIT_LENGTH;
            
            // 2. é‡ç½®è§£é–ç‹€æ…‹
            unlockStatus = {}; 
            Object.keys(ITEM_TEMPLATES).forEach(k => unlockStatus[k] = 0);
            
            // 3. ç”Ÿæˆæ‹¼åœ– (ç¢ºä¿æœ‰è§£)
            items = [];
            let grid = Array(ROWS_BACKPACK).fill().map(()=>Array(COLS_BACKPACK).fill(0));
            
            // å…ˆå¡«æ»¿ç¶²æ ¼
            for(let r=0; r<ROWS_BACKPACK; r++) {
                for(let c=0; c<COLS_BACKPACK; c++) {
                    if(!grid[r][c]) tryPlace(grid, r, c);
                }
            }
            
            // 4. å°‡ç‰©å“æ•£å¸ƒåˆ°å³å´ç­‰å¾…å€
            let spawnCol = COLS_BACKPACK + COLS_GAP;
            items.forEach(it => {
                it.logicalX = spawnCol + Math.random() * (COLS_SPAWN - it.cols);
                it.logicalY = Math.random() * (ROWS_BACKPACK - it.rows);
                
                // éš¨æ©Ÿæ—‹è½‰
                let rot = Math.floor(Math.random()*4);
                for(let i=0; i<rot; i++) it.rotate();
                
                // é˜²æ­¢è¶…å‡ºé‚Šç•Œ
                if(it.logicalX + it.cols > TOTAL_LOGICAL_COLS) it.logicalX = TOTAL_LOGICAL_COLS - it.cols;
                if(it.logicalY + it.rows > TOTAL_LOGICAL_ROWS) it.logicalY = TOTAL_LOGICAL_ROWS - it.rows;
            });
            draw();
        }
        
        // å˜—è©¦åœ¨ç¶²æ ¼æ”¾ç½®ä¸€å€‹éš¨æ©Ÿå½¢ç‹€
        function tryPlace(grid, r, c) {
            let shapes = [...SHAPES].sort(()=>Math.random()-0.5);
            for(let s of shapes) {
                if(canFit(grid, r, c, s)) {
                    let key = getKey(s);
                    let it = new Item(s, key);
                    items.push(it);
                    mark(grid, r, c, s, 1);
                    return;
                }
            }
        }
        
        // æª¢æŸ¥å½¢ç‹€æ˜¯å¦æ”¾å¾—ä¸‹
        function canFit(g, r, c, s) {
            if(r + s.length > ROWS_BACKPACK || c + s[0].length > COLS_BACKPACK) return false;
            for(let i=0; i<s.length; i++) {
                for(let j=0; j<s[0].length; j++) {
                    if(s[i][j] && g[r+i][c+j]) return false;
                }
            }
            return true;
        }
        
        // æ¨™è¨˜ç¶²æ ¼å·²ä½”ç”¨
        function mark(g, r, c, s, v) { 
            for(let i=0; i<s.length; i++) {
                for(let j=0; j<s[0].length; j++) {
                    if(s[i][j]) g[r+i][c+j] = v;
                }
            }
        }
        
        // æ ¹æ“šå½¢ç‹€æ±ºå®šå¤–è§€ (Theme)
        function getKey(s) {
            let a=0; s.flat().forEach(v=>a+=v);
            if(a===1) return 'eraser';
            if(s.length===1 || s[0].length===1) return a>=3 ? 'ruler' : 'pencil_box';
            let rect=true; for(let row of s) if(row.includes(0)) rect=false;
            if(rect) return a>=4 ? (Math.random()>.5 ? 'book' : 'notebook') : 'tetris';
            return Math.random()<.3 ? 'headphones' : (Math.random()<.6 ? 'gameboy' : 'tetris');
        }

        // --- ç¢°æ’æª¢æ¸¬ ---
        function checkColl(item, tx, ty) {
            // 1. æª¢æŸ¥é‚Šç•Œ
            for(let r=0; r<item.rows; r++) {
                for(let c=0; c<item.cols; c++) {
                    if(item.shape[r][c]) {
                        let gx=tx+c, gy=ty+r;
                        if(gx<0 || gx>=COLS_BACKPACK || gy<0 || gy>=ROWS_BACKPACK) return true;
                    }
                }
            }
            // 2. æª¢æŸ¥èˆ‡å…¶ä»–ç‰©å“é‡ç–Š
            for(let o of items) {
                if(o===item || !o.isInside) continue;
                let ox = Math.round(o.logicalX), oy = Math.round(o.logicalY);
                for(let r=0; r<item.rows; r++) {
                    for(let c=0; c<item.cols; c++) {
                        if(item.shape[r][c]) {
                            let rx = (tx+c)-ox, ry = (ty+r)-oy;
                            if(rx>=0 && rx<o.cols && ry>=0 && ry<o.rows && o.shape[ry][rx]) return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- æ”¾ç½®é‚è¼¯ (Dropping) ---
        function onDrop(item, cx, cy) {
            // æª¢æŸ¥ä½ç½®åˆæ³•æ€§
            if(checkColl(item, cx, cy)) {
                returnBounce(item, "â›” ä½ç½®ä¸åˆæ³• (é‡ç–Šæˆ–å‡ºç•Œ)"); 
                return;
            }
            
            // æª¢æŸ¥è§£é–ç‹€æ…‹
            if(unlockStatus[item.key] > 0) {
                // å·²æœ‰æ¬¡æ•¸ï¼Œç›´æ¥æ‰£é™¤
                unlockStatus[item.key]--;
                place(item, cx, cy);
                uiFeedback.innerText = `âœ… æ”¾ç½®æˆåŠŸï¼(å‰©é¤˜å…è²»æ¬¡æ•¸: ${unlockStatus[item.key]})`;
            } else {
                // ç„¡æ¬¡æ•¸ï¼Œè§¸ç™¼æ•¸å­¸é¡Œç›®
                askMath(item, cx, cy);
            }
        }

        // é¡¯ç¤ºæ•¸å­¸é¡Œç›®
        function askMath(item, cx, cy) {
            pendingItem = item; 
            pendingCol = cx; 
            pendingRow = cy;
            
            let area = item.area;
            // é¡¯ç¤ºé¡Œç›®ï¼šæ ¼å­æ•¸ x é‚Šé•·å¹³æ–¹
            quizText.innerHTML = `
                ç©æœ¨ä½”äº† <b style="color:#d81b60">${area}</b> æ ¼<br>
                æ¯æ ¼é‚Šé•·ï¼š<b style="color:#0277bd">${UNIT_LENGTH}</b><br>
                ç¸½é¢ç©æ˜¯å¤šå°‘ï¼Ÿ
            `;
            quizInput.value = ""; 
            modal.style.display = "flex"; 
            quizInput.focus();
        }

        // é€å‡ºç­”æ¡ˆè™•ç†
        quizSubmit.onclick = () => {
            let ans = parseInt(quizInput.value);
            let correct = pendingItem.area * (UNIT_LENGTH * UNIT_LENGTH);
            modal.style.display = "none";
            
            if(ans === correct) {
                unlockStatus[pendingItem.key] = 2; // çå‹µ 2 æ¬¡ + é€™æ¬¡ 1 æ¬¡ = å…± 3 æ¬¡
                place(pendingItem, pendingCol, pendingRow);
                uiFeedback.innerText = "ğŸ‰ ç­”å°äº†ï¼çå‹µé¡å¤– 2 æ¬¡å…è²»æ”¾ç½®ï¼";
                uiFeedback.style.color = "green";
            } else {
                returnBounce(pendingItem, "âŒ ç­”æ¡ˆéŒ¯èª¤ï¼ç©æœ¨å½ˆå›");
            }
        }

        // ç¢ºèªæ”¾ç½®
        function place(item, x, y) {
            item.logicalX = x; 
            item.logicalY = y; 
            item.isInside = true;
            if(navigator.vibrate) navigator.vibrate(30);
            updateUI(); 
            draw();
        }
        
        // å½ˆå›åŸè™•
        function returnBounce(item, msg) {
            item.logicalX = originalPos.x; 
            item.logicalY = originalPos.y; 
            item.isInside = false;
            uiFeedback.innerText = msg; 
            uiFeedback.style.color = "#d32f2f";
            draw();
        }
        
        // æ›´æ–°è¦†è“‹ç‡ä»‹é¢
        function updateUI() {
            let used=0; 
            items.forEach(i => { if(i.isInside) used += i.area; });
            uiCoverage.innerText = Math.round(used / (ROWS_BACKPACK * COLS_BACKPACK) * 100) + "%";
        }

        // --- ç¹ªè£½ä¸»è¿´åœˆ ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½èƒŒåŒ…å€åŸŸ
            ctx.fillStyle = "white"; 
            ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            
            // ç¹ªè£½ç¶²æ ¼ç·š
            ctx.strokeStyle = "#eee"; ctx.lineWidth=1; ctx.beginPath();
            for(let i=0; i<=COLS_BACKPACK; i++) { 
                ctx.moveTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y); 
                ctx.lineTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+BACKPACK_H); 
            }
            for(let i=0; i<=ROWS_BACKPACK; i++) { 
                ctx.moveTo(OFFSET_X, OFFSET_Y+i*GRID_SIZE); 
                ctx.lineTo(OFFSET_X+BACKPACK_W, OFFSET_Y+i*GRID_SIZE); 
            }
            ctx.stroke();
            
            // ç¹ªè£½èƒŒåŒ…å¤–æ¡†
            ctx.strokeStyle = "#795548"; ctx.lineWidth=3; 
            ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);

            // ç¹ªè£½æ‰€æœ‰ç‰©å“
            items.forEach(i => { if(i !== draggedItem) i.draw(ctx); });
            
            // ç¹ªè£½æ‹–æ›³ä¸­çš„ç‰©å“ (åŠé€æ˜é™°å½±)
            if(draggedItem) { 
                ctx.save(); 
                ctx.globalAlpha=0.8; 
                ctx.shadowBlur=10; 
                ctx.shadowColor="black"; 
                draggedItem.draw(ctx); 
                ctx.restore(); 
            }
        }

        // --- è¼¸å…¥äº‹ä»¶è™•ç† (Mouse & Touch) ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return {x: cx - r.left, y: cy - r.top};
        }

        function start(e) {
            if(e.type==='touchstart') e.preventDefault(); // é˜²æ­¢æ²å‹•
            const {x, y} = getPos(e);
            const now = Date.now();
            
            // å€’åºæª¢æŸ¥ (å„ªå…ˆé¸å–æœ€ä¸Šå±¤çš„ç‰©å“)
            for(let i=items.length-1; i>=0; i--) {
                if(items[i].hitTest(x, y)) {
                    // é›™æ“Šæª¢æ¸¬
                    if(now - lastClickTime < 300) { 
                        items[i].rotate(); 
                        draw(); 
                        lastClickTime = 0; 
                        return; 
                    }
                    lastClickTime = now;
                    
                    // é–‹å§‹æ‹–æ›³
                    draggedItem = items[i]; 
                    originalPos = {x: draggedItem.logicalX, y: draggedItem.logicalY};
                    
                    // è¨ˆç®—æ»‘é¼ é»æ“Šé»ç›¸å°æ–¼ç‰©å“å·¦ä¸Šè§’çš„åç§»
                    dragOffsetGridX = (x / GRID_SIZE) - draggedItem.logicalX - (OFFSET_X / GRID_SIZE);
                    dragOffsetGridY = (y / GRID_SIZE) - draggedItem.logicalY - (OFFSET_Y / GRID_SIZE);
                    
                    // å°‡ç‰©å“ç§»è‡³é™£åˆ—æœ€å¾Œ (é¡¯ç¤ºåœ¨æœ€ä¸Šå±¤)
                    items.splice(i, 1); 
                    items.push(draggedItem);
                    draw(); 
                    return;
                }
            }
        }

        function move(e) {
            if(!draggedItem) return;
            if(e.type==='touchmove') e.preventDefault();
            const {x, y} = getPos(e);
            
            // æ›´æ–°ç‰©å“ä½ç½® (è·Ÿéš¨æ»‘é¼ )
            draggedItem.logicalX = (x / GRID_SIZE) - dragOffsetGridX - (OFFSET_X / GRID_SIZE);
            draggedItem.logicalY = (y / GRID_SIZE) - dragOffsetGridY - (OFFSET_Y / GRID_SIZE);
            draw();
        }

        function end(e) {
            if(!draggedItem) return;
            
            // è¨ˆç®—æœ€è¿‘çš„æ ¼å­åº§æ¨™ (Snap to Grid)
            let cx = Math.round(draggedItem.logicalX);
            let cy = Math.round(draggedItem.logicalY);
            
            // å¦‚æœæ”¾å…¥èƒŒåŒ…å€ (Column < 10)ï¼Œè§¸ç™¼æ”¾ç½®é‚è¼¯
            if(cx < COLS_BACKPACK) {
                onDrop(draggedItem, cx, cy);
            } else { 
                // å¦å‰‡åªæ˜¯åœ¨ç‰©å“å€ç§»å‹•ï¼Œç›´æ¥æ”¾ç½®
                draggedItem.logicalX = cx; 
                draggedItem.logicalY = cy; 
                draw(); 
            }
            draggedItem = null;
        }

        // ç¶å®šäº‹ä»¶
        canvas.addEventListener('mousedown', start); 
        document.addEventListener('mousemove', move); 
        document.addEventListener('mouseup', end);
        
        canvas.addEventListener('touchstart', start, {passive:false}); 
        document.addEventListener('touchmove', move, {passive:false}); 
        document.addEventListener('touchend', end);
        
        // æŒ‰éˆ•äº‹ä»¶
        document.getElementById('btn-new').onclick = () => { initGame(); updateUI(); };
        window.onresize = resizeGame;

        // å•Ÿå‹•éŠæˆ²
        initGame();
        // å»¶é²ä¸€ä¸‹ç¢ºä¿ CSS ä½ˆå±€å®Œæˆ
        setTimeout(resizeGame, 100);

    </script>
</body>
</html>
