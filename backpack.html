<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èƒŒåŒ…æ•¸å­¸å¤§å¸«</title>
    <style>
        :root { --header-height: 60px; --feedback-height: 30px; }
        html, body {
            width: 100%; height: 100%; height: 100dvh; margin: 0; padding: 0; overflow: hidden;
            background-color: #fff8e1; font-family: 'Segoe UI', sans-serif; touch-action: none;
            position: fixed; display: flex; flex-direction: column;
        }
        .dashboard {
            flex: 0 0 var(--header-height); width: 100%; display: flex; justify-content: space-between;
            align-items: center; background: white; padding: 0 10px; box-sizing: border-box;
            border-bottom: 3px solid #ffb74d; z-index: 10; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #math-feedback {
            flex: 0 0 var(--feedback-height); font-size: 15px; color: #5d4037; font-weight: bold;
            display: flex; align-items: center; justify-content: center; background: #fff8e1; width: 100%;
        }
        .game-container {
            flex: 1; width: 100%; position: relative; display: flex; justify-content: center; align-items: center;
            overflow: hidden; padding: 5px; box-sizing: border-box;
        }
        canvas { border-radius: 12px; background: #ffffff; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .stat-group { display: flex; gap: 8px; align-items: center; font-size: 14px; font-weight: bold; color: #5d4037; }
        .unit-badge { background: #e1f5fe; color: #0277bd; padding: 4px 8px; border-radius: 6px; border: 1px solid #0277bd; }
        .instruction-tag {
            background: #fff3e0; color: #ef6c00; border: 2px dashed #ffb74d; padding: 5px 10px;
            border-radius: 20px; font-weight: bold; font-size: 15px; display: flex; align-items: center;
            animation: pulse 2s infinite;
        }
        button { 
            padding: 8px 14px; font-size: 14px; border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; color: white; box-shadow: 0 2px 0 rgba(0,0,0,0.2); white-space: nowrap;
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        #btn-new { background-color: #66bb6a; }
        @keyframes pulse { 0% {transform:scale(1);} 50% {transform:scale(1.05);} 100% {transform:scale(1);} }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6);
            display: none; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(2px);
        }
        .modal-box {
            background: white; padding: 20px; border-radius: 15px; text-align: center; width: 320px;
            border: 4px solid #ffb74d; box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        .modal-title { font-size: 22px; color: #d81b60; margin-bottom: 10px; font-weight: bold; }
        .modal-question { font-size: 18px; color: #333; margin-bottom: 15px; line-height: 1.6; }
        .modal-input { font-size: 24px; padding: 5px; width: 100px; text-align: center; border: 2px solid #ccc; border-radius: 8px; margin-bottom: 15px; }
        .modal-btn { padding: 10px 24px; font-size: 18px; border-radius: 8px; border: none; cursor: pointer; color: white; background: #1e88e5; }
    </style>
</head>
<body>

    <div class="dashboard">
        <div class="stat-group">
            <div class="unit-badge">ğŸ“ é‚Šé•·: <span id="unit-len">1</span></div>
            <div><span id="coverage" style="color:#d81b60">0%</span></div>
        </div>
        <div class="instruction-tag">ğŸ‘† é»å…©ä¸‹æ—‹è½‰</div>
        <div><button id="btn-new">ğŸ”„ é‡ä¾†</button></div>
    </div>

    <div id="math-feedback">æ‹–æ›³ç©æœ¨å¡«æ»¿èƒŒåŒ… | ç­”å°é¢ç©å¯ç²å¾—ä¸‰æ¬¡æ©Ÿæœƒ</div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="modal-overlay" id="quiz-modal">
        <div class="modal-box">
            <div class="modal-title">ğŸ§  é¢ç©å¤§æŒ‘æˆ°</div>
            <div class="modal-question" id="quiz-text"></div>
            <input type="number" class="modal-input" id="quiz-input" placeholder="?">
            <br>
            <button class="modal-btn" id="btn-quiz-submit">é€å‡ºç­”æ¡ˆ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiCoverage = document.getElementById('coverage');
        const uiFeedback = document.getElementById('math-feedback');
        const uiUnitLen = document.getElementById('unit-len');
        
        const modal = document.getElementById('quiz-modal');
        const quizText = document.getElementById('quiz-text');
        const quizInput = document.getElementById('quiz-input');
        const quizSubmit = document.getElementById('btn-quiz-submit');

        const COLS_BACKPACK = 10; 
        const ROWS_BACKPACK = 8;
        const COLS_GAP = 1;
        const COLS_SPAWN = 4;
        
        const TOTAL_LOGICAL_COLS = COLS_BACKPACK + COLS_GAP + COLS_SPAWN;
        const TOTAL_LOGICAL_ROWS = ROWS_BACKPACK;

        let GRID_SIZE = 40;
        let OFFSET_X = 0;
        let OFFSET_Y = 0;
        let BACKPACK_W, BACKPACK_H;

        let UNIT_LENGTH = 2;
        const POSSIBLE_LENGTHS = [2, 3, 4, 5, 6, 7, 8, 9, 10]; // é‚Šé•·ç¯„åœ 2~10
        let unlockStatus = {};

        let items = [];
        let draggedItem = null;
        let dragOffsetGridX = 0;
        let dragOffsetGridY = 0;
        let lastClickTime = 0;
        let pendingItem = null;
        let pendingCol = 0, pendingRow = 0;
        let originalPos = {x:0, y:0};

        const SHAPES = [
            [[1]], [[1,1]], [[1,1,1]], 
            [[1,1,1,1]], [[1,1],[1,1]], [[1,1,1],[1,0,0]], [[1,1,1],[0,1,0]], [[1,1,0],[0,1,1]],
            [[1,1,1,1,1]], [[1,1,1],[1,0,1]], [[1,1],[1,1],[1,0]], [[1,1,1],[0,1,0],[0,1,0]], [[1,1,1],[1,0,0],[1,0,0]],
            [[1,1,1],[1,1,1]], [[1,1],[1,0],[1,0],[1,1]], [[1,1,1],[0,1,0],[0,1,0],[0,1,0]], [[1,1,1,1],[1,0,0,0],[1,0,0,0]]
        ];

        class Item {
            constructor(shape, key) {
                this.shape = shape; this.key = key;
                this.template = ITEM_TEMPLATES[key]; this.color = this.template.color;
                this.logicalX = 0; this.logicalY = 0;
                this.isInside = false; this.updateDimensions();
            }
            updateDimensions() {
                this.rows = this.shape.length; this.cols = this.shape[0].length;
                this.area = 0; this.shape.flat().forEach(v => this.area += v);
            }
            rotate() {
                let newShape = new Array(this.cols).fill(0).map(() => new Array(this.rows).fill(0));
                for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) newShape[c][this.rows-1-r] = this.shape[r][c];
                this.shape = newShape; this.updateDimensions();
            }
            draw(ctx) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                if(this.template.draw) this.template.draw(ctx, px, py, this);
                if(unlockStatus[this.key] <= 0 && !this.isInside && draggedItem !== this) {
                    ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.font = `${GRID_SIZE/2}px Arial`;
                    ctx.textAlign = "center"; ctx.fillText("ğŸ”’", px + GRID_SIZE/2, py + GRID_SIZE/2 + 5);
                }
            }
            hitTest(mx, my) {
                const px = OFFSET_X + this.logicalX * GRID_SIZE;
                const py = OFFSET_Y + this.logicalY * GRID_SIZE;
                if(mx < px || mx > px + this.cols*GRID_SIZE || my < py || my > py + this.rows*GRID_SIZE) return false;
                let c = Math.floor((mx - px) / GRID_SIZE);
                let r = Math.floor((my - py) / GRID_SIZE);
                return (r >= 0 && r < this.rows && c >= 0 && c < this.cols && this.shape[r][c] === 1);
            }
        }

        function drawBase(ctx, x, y, color, size) { 
            ctx.fillStyle = color; ctx.fillRect(x, y, size, size); 
            ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.fillRect(x, y, size, size * 0.2); 
            ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.strokeRect(x, y, size, size);
        }
        function iter(item, px, py, callback) {
            for(let r=0; r<item.rows; r++) for(let c=0; c<item.cols; c++) if(item.shape[r][c]) callback(px + c * GRID_SIZE, py + r * GRID_SIZE, r, c);
        }

        const ITEM_TEMPLATES = {
            'ruler': { color: '#fdd835', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.strokeStyle="#5d4037"; ctx.beginPath(); ctx.moveTo(x+GRID_SIZE/2, y); ctx.lineTo(x+GRID_SIZE/2, y+GRID_SIZE/2); ctx.stroke(); }); } },
            'book': { color: '#42a5f5', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.fillStyle="rgba(255,255,255,0.4)"; ctx.fillRect(x+3, y, 3, GRID_SIZE); }); } },
            'notebook': { color: '#66bb6a', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y, r) => { drawBase(ctx, x, y, it.color, GRID_SIZE); if(r===0){ ctx.fillStyle="#333"; ctx.beginPath(); ctx.arc(x+GRID_SIZE/2, y+4, 2, 0, 6.28); ctx.fill();} }); } },
            'pencil_box': { color: '#ef5350', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.fillRect(x, y+GRID_SIZE/2-2, GRID_SIZE, 4); }); } },
            'eraser': { color: '#f48fb1', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.fillStyle="white"; ctx.font=`${GRID_SIZE/3}px Arial`; ctx.textAlign="center"; ctx.fillText("E", x+GRID_SIZE/2, y+GRID_SIZE/2+3); }); } },
            'headphones': { color: '#ab47bc', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.font=`${GRID_SIZE/2}px Arial`; ctx.textAlign="center"; ctx.fillText("ğŸ§", x+GRID_SIZE/2, y+GRID_SIZE*0.7); }); } },
            'gameboy': { color: '#26c6da', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.fillStyle="#004d40"; ctx.fillRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE*0.4); ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(x+GRID_SIZE*0.8, y+GRID_SIZE*0.8, 3, 0, 6.28); ctx.fill(); }); } },
            'tetris': { color: '#ff7043', draw: (ctx, px, py, it) => { iter(it, px, py, (x, y) => { drawBase(ctx, x, y, it.color, GRID_SIZE); ctx.strokeStyle="white"; ctx.strokeRect(x+4, y+4, GRID_SIZE-8, GRID_SIZE-8); }); } }
        };

        function resizeGame() {
            const container = document.querySelector('.game-container');
            const cW = container.clientWidth; const cH = container.clientHeight;
            const sW = (cW - 20) / TOTAL_LOGICAL_COLS; const sH = (cH - 20) / TOTAL_LOGICAL_ROWS;
            GRID_SIZE = Math.floor(Math.min(sW, sH));
            canvas.width = cW; canvas.height = cH;
            const contentW = TOTAL_LOGICAL_COLS * GRID_SIZE; const contentH = TOTAL_LOGICAL_ROWS * GRID_SIZE;
            OFFSET_X = Math.floor((cW - contentW) / 2); OFFSET_Y = Math.floor((cH - contentH) / 2);
            BACKPACK_W = COLS_BACKPACK * GRID_SIZE; BACKPACK_H = ROWS_BACKPACK * GRID_SIZE;
            draw();
        }

        function initGame() {
            UNIT_LENGTH = POSSIBLE_LENGTHS[Math.floor(Math.random() * POSSIBLE_LENGTHS.length)];
            uiUnitLen.innerText = UNIT_LENGTH;
            unlockStatus = {}; Object.keys(ITEM_TEMPLATES).forEach(k => unlockStatus[k] = 0);
            
            items = [];
            let grid = Array(ROWS_BACKPACK).fill().map(() => Array(COLS_BACKPACK).fill(0));
            
            for(let r=0; r<ROWS_BACKPACK; r++) {
                for(let c=0; c<COLS_BACKPACK; c++) {
                    if(!grid[r][c]) tryPlace(grid, r, c);
                }
            }
            
            let spawnCol = COLS_BACKPACK + COLS_GAP;
            items.forEach(it => {
                it.logicalX = spawnCol + Math.random() * (COLS_SPAWN - it.cols);
                it.logicalY = Math.random() * (ROWS_BACKPACK - it.rows);
                let rot = Math.floor(Math.random() * 4);
                for(let i=0; i<rot; i++) it.rotate();
                if(it.logicalX + it.cols > TOTAL_LOGICAL_COLS) it.logicalX = TOTAL_LOGICAL_COLS - it.cols;
                if(it.logicalY + it.rows > TOTAL_LOGICAL_ROWS) it.logicalY = TOTAL_LOGICAL_ROWS - it.rows;
            });
            draw();
        }
        
        function tryPlace(grid, r, c) {
            let shapes = [...SHAPES].sort((a, b) => {
                let areaA = a.flat().reduce((acc, v) => acc + v, 0);
                let areaB = b.flat().reduce((acc, v) => acc + v, 0);
                return areaB - areaA || Math.random() - 0.5;
            });
            
            for(let s of shapes) {
                if(canFit(grid, r, c, s)) {
                    let key = getKey(s);
                    let it = new Item(s, key);
                    items.push(it);
                    mark(grid, r, c, s, 1);
                    return;
                }
            }
        }
        
        function canFit(g, r, c, s) {
            if(r + s.length > ROWS_BACKPACK || c + s[0].length > COLS_BACKPACK) return false;
            for(let i=0; i<s.length; i++) for(let j=0; j<s[0].length; j++) if(s[i][j] && g[r+i][c+j]) return false;
            return true;
        }
        function mark(g, r, c, s, v) { 
            for(let i=0; i<s.length; i++) for(let j=0; j<s[0].length; j++) if(s[i][j]) g[r+i][c+j] = v;
        }
        
        function getKey(s) {
            let area = 0; s.flat().forEach(v => area += v);
            if (area >= 6) return Math.random() < 0.5 ? 'gameboy' : 'tetris';
            if (area === 5) return Math.random() < 0.5 ? 'headphones' : 'book';
            if (area === 1) return 'eraser';
            if (s.length === 1 || s[0].length === 1) return area >= 3 ? 'ruler' : 'pencil_box';
            let isRect = true; for(let row of s) if(row.includes(0)) isRect = false;
            if(isRect) return area >= 4 ? (Math.random() > 0.5 ? 'book' : 'notebook') : 'tetris';
            return 'tetris';
        }

        function checkColl(item, tx, ty) {
            for(let r=0; r<item.rows; r++) for(let c=0; c<item.cols; c++) if(item.shape[r][c]) {
                let gx = tx+c, gy = ty+r;
                if(gx < 0 || gx >= COLS_BACKPACK || gy < 0 || gy >= ROWS_BACKPACK) return true;
            }
            for(let o of items) {
                if(o === item || !o.isInside) continue;
                let ox = Math.round(o.logicalX), oy = Math.round(o.logicalY);
                for(let r=0; r<item.rows; r++) for(let c=0; c<item.cols; c++) if(item.shape[r][c]) {
                    let rx = (tx+c)-ox, ry = (ty+r)-oy;
                    if(rx >= 0 && rx < o.cols && ry >= 0 && ry < o.rows && o.shape[ry][rx]) return true;
                }
            }
            return false;
        }

        function onDrop(item, cx, cy) {
            if(checkColl(item, cx, cy)) { returnBounce(item, "â›” ä½ç½®ä¸åˆæ³•"); return; }
            if(unlockStatus[item.key] > 0) {
                unlockStatus[item.key]--; place(item, cx, cy);
                uiFeedback.innerText = `âœ… æ”¾ç½®æˆåŠŸï¼(å‰©é¤˜æ¬¡æ•¸: ${unlockStatus[item.key]})`;
            } else { askMath(item, cx, cy); }
        }

        function askMath(item, cx, cy) {
            pendingItem = item; pendingCol = cx; pendingRow = cy;
            quizText.innerHTML = `ç©æœ¨ä½”äº† <b style="color:#d81b60">${item.area}</b> æ ¼<br>æ¯æ ¼é‚Šé•·ï¼š<b style="color:#0277bd">${UNIT_LENGTH}</b><br>ç¸½é¢ç©æ˜¯å¤šå°‘ï¼Ÿ`;
            quizInput.value = ""; modal.style.display = "flex"; quizInput.focus();
        }

        quizSubmit.onclick = () => {
            let ans = parseInt(quizInput.value);
            let correct = pendingItem.area * (UNIT_LENGTH * UNIT_LENGTH);
            modal.style.display = "none";
            if(ans === correct) {
                unlockStatus[pendingItem.key] = 2; place(pendingItem, pendingCol, pendingRow);
                uiFeedback.innerText = "ğŸ‰ ç­”å°äº†ï¼çå‹µ 3 æ¬¡å…è²»æ”¾ç½®ï¼";
            } else { returnBounce(pendingItem, "âŒ ç­”æ¡ˆéŒ¯èª¤ï¼ç©æœ¨å½ˆå›"); }
        }

        function place(item, x, y) { item.logicalX = x; item.logicalY = y; item.isInside = true; if(navigator.vibrate) navigator.vibrate(30); updateUI(); draw(); }
        function returnBounce(item, msg) { item.logicalX = originalPos.x; item.logicalY = originalPos.y; item.isInside = false; uiFeedback.innerText = msg; uiFeedback.style.color = "#d32f2f"; draw(); }
        function updateUI() { let used = 0; items.forEach(i => { if(i.isInside) used += i.area; }); uiCoverage.innerText = Math.round(used / (ROWS_BACKPACK * COLS_BACKPACK) * 100) + "%"; }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white"; ctx.fillRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            ctx.strokeStyle = "#eee"; ctx.lineWidth = 1; ctx.beginPath();
            for(let i=0; i<=COLS_BACKPACK; i++) { ctx.moveTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y); ctx.lineTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+BACKPACK_H); }
            for(let i=0; i<=ROWS_BACKPACK; i++) { ctx.moveTo(OFFSET_X, OFFSET_Y+i*GRID_SIZE); ctx.lineTo(OFFSET_X+BACKPACK_W, OFFSET_Y+i*GRID_SIZE); }
            ctx.stroke();
            ctx.strokeStyle = "#795548"; ctx.lineWidth = 3; ctx.strokeRect(OFFSET_X, OFFSET_Y, BACKPACK_W, BACKPACK_H);
            items.forEach(i => { if(i !== draggedItem) i.draw(ctx); });
            if(draggedItem) { ctx.save(); ctx.globalAlpha = 0.8; ctx.shadowBlur = 10; ctx.shadowColor = "black"; draggedItem.draw(ctx); ctx.restore(); }
        }

        function getPos(e) { const r = canvas.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; return {x: cx - r.left, y: cy - r.top}; }
        function start(e) {
            if(e.type === 'touchstart') e.preventDefault();
            const {x, y} = getPos(e); const now = Date.now();
            for(let i=items.length-1; i>=0; i--) {
                if(items[i].hitTest(x, y)) {
                    if(now - lastClickTime < 300) { items[i].rotate(); draw(); lastClickTime = 0; return; }
                    lastClickTime = now; draggedItem = items[i]; originalPos = {x: draggedItem.logicalX, y: draggedItem.logicalY};
                    dragOffsetGridX = (x / GRID_SIZE) - draggedItem.logicalX - (OFFSET_X / GRID_SIZE);
                    dragOffsetGridY = (y / GRID_SIZE) - draggedItem.logicalY - (OFFSET_Y / GRID_SIZE);
                    items.splice(i, 1); items.push(draggedItem); draw(); return;
                }
            }
        }
        function move(e) {
            if(!draggedItem) return; if(e.type === 'touchmove') e.preventDefault();
            const {x, y} = getPos(e);
            draggedItem.logicalX = (x / GRID_SIZE) - dragOffsetGridX - (OFFSET_X / GRID_SIZE);
            draggedItem.logicalY = (y / GRID_SIZE) - dragOffsetGridY - (OFFSET_Y / GRID_SIZE);
            draw();
        }
        function end(e) {
            if(!draggedItem) return;
            let cx = Math.round(draggedItem.logicalX); let cy = Math.round(draggedItem.logicalY);
            if(cx < COLS_BACKPACK) onDrop(draggedItem, cx, cy); else { draggedItem.logicalX = cx; draggedItem.logicalY = cy; draw(); }
            draggedItem = null;
        }

        canvas.addEventListener('mousedown', start); document.addEventListener('mousemove', move); document.addEventListener('mouseup', end);
        canvas.addEventListener('touchstart', start, {passive:false}); document.addEventListener('touchmove', move, {passive:false}); document.addEventListener('touchend', end);
        document.getElementById('btn-new').onclick = () => { initGame(); updateUI(); };
        window.onresize = resizeGame;

        initGame();
        setTimeout(resizeGame, 100);
    </script>
</body>
</html>
