<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>äº”è¡Œæ‰‹å¯«å°æˆ°éŠæˆ²ï¼ˆHanziLookupJS ç‰ˆï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- æ‰‹å¯«è¾¨è­˜ï¼šHanziLookupJSï¼ˆéœ€æ­é… mmah.jsonï¼‰ -->
  <script src="hanzilookup.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 1rem;
      background: #f4f5fb;
      color: #222;
    }

    h1 {
      font-size: 1.4rem;
      text-align: center;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      text-align: center;
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 1rem;
    }

    .game-container {
      max-width: 900px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      padding: 1rem;
    }

    .hp-row {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .hp-box {
      flex: 1 1 150px;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      background: #f7f7ff;
    }

    .hp-title {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }

    .hp-value {
      font-weight: bold;
      font-size: 1.1rem;
    }

    .hp-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: #e0e0f0;
      overflow: hidden;
      margin-top: 0.25rem;
    }

    .hp-bar-inner {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #4caf50, #ff9800);
      transition: width 0.3s;
    }

    .main-layout {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .left-panel, .right-panel {
      flex: 1 1 260px;
    }

    .canvas-wrapper {
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fafafa;
      padding: 0.5rem;
    }

    .canvas-title {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }

    canvas {
      width: 100%;
      height: 220px;
      border-radius: 6px;
      background: #ffffff;
      touch-action: none;
      border: 1px solid #ddd;
    }

    .controls {
      margin-top: 0.5rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    button {
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      border: none;
      font-size: 0.9rem;
      cursor: pointer;
      background: #3f51b5;
      color: white;
      min-width: 100px;
    }

    button.secondary {
      background: #9e9e9e;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .info-panel {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      background: #f9fafc;
      border: 1px solid #e0e3ff;
      font-size: 0.85rem;
    }

    .info-panel h2 {
      font-size: 1rem;
      margin-top: 0;
    }

    .log {
      margin-top: 0.75rem;
      height: 220px;
      overflow-y: auto;
      padding: 0.5rem;
      background: #101322;
      color: #e0e0ff;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
    }

    .log-line {
      margin-bottom: 0.25rem;
      white-space: pre-wrap;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #e8eaf6;
      color: #303f9f;
      margin-left: 4px;
    }

    .footer-hint {
      margin-top: 0.75rem;
      font-size: 0.75rem;
      color: #777;
    }

    .status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #555;
      min-height: 1.2em;
    }

    .status span {
      font-weight: bold;
    }

    .timer {
      margin-top: 0.25rem;
      font-size: 0.9rem;
      color: #c62828;
      font-weight: bold;
      min-height: 1.2em;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 1.2rem;
      }
      .subtitle {
        font-size: 0.8rem;
      }
      button {
        flex: 1 1 auto;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>äº”è¡Œæ‰‹å¯«å°æˆ°éŠæˆ²ï¼ˆHanziLookupJS ç‰ˆï¼‰</h1>
    <div class="subtitle">æ¯å›åˆ 5 ç§’å…§åœ¨ç•«å¸ƒæ‰‹å¯«ä¸€å€‹å­— â†’ æœ¬åœ°æ‰‹å¯«è¾¨è­˜ â†’ ç©å®¶å…ˆæ”»ã€NPC å¾Œæ”»</div>

    <div class="hp-row">
      <div class="hp-box">
        <div class="hp-title">ç©å®¶ HP</div>
        <div class="hp-value" id="playerHpText">100 / 100</div>
        <div class="hp-bar"><div class="hp-bar-inner" id="playerHpBar"></div></div>
      </div>
      <div class="hp-box">
        <div class="hp-title">NPC HP</div>
        <div class="hp-value" id="enemyHpText">100 / 100</div>
        <div class="hp-bar"><div class="hp-bar-inner" id="enemyHpBar"></div></div>
      </div>
    </div>

    <div class="main-layout">
      <!-- å·¦å´ï¼šç•«å¸ƒï¼‹æ“ä½œ -->
      <div class="left-panel">
        <div class="canvas-wrapper">
          <div class="canvas-title">åœ¨é€™è£¡æ‰‹å¯«ä½ è¦ä½¿ç”¨çš„ã€Œå­—ã€</div>
          <canvas id="drawCanvas"></canvas>
          <div class="controls">
            <button id="startTurnBtn">é–‹å§‹å›åˆï¼ˆ5 ç§’å€’æ•¸ï¼‰</button>
            <button id="clearCanvasBtn" class="secondary">æ¸…é™¤ç•«å¸ƒ</button>
            <button id="restartBtn" class="secondary">é‡æ–°é–‹å§‹æˆ°é¬¥</button>
          </div>
          <div class="timer" id="timerText"></div>
          <div class="status" id="statusText"></div>
        </div>
      </div>

      <!-- å³å´ï¼šèªªæ˜ï¼‹æˆ°æ³ -->
      <div class="right-panel">
        <div class="info-panel">
          <h2>è¦å‰‡æ‘˜è¦</h2>
          <p>1. æ¯å›åˆæµç¨‹ï¼š</p>
          <ul>
            <li>æŒ‰ã€Œé–‹å§‹å›åˆã€å¾Œé–‹å§‹å€’æ•¸ <strong>5 ç§’</strong></li>
            <li>5 ç§’å…§åœ¨ç•«å¸ƒä¸Šæ‰‹å¯«ä¸€å€‹å­—ï¼ˆç­†ç•«è¶Šå¤šæ”»æ“Šè¶Šé«˜ï¼‰</li>
            <li>æ™‚é–“åˆ° â†’ è®€å–ä½ çš„ç­†ç•«è»Œè·¡ï¼Œä½¿ç”¨ HanziLookupJS åšæ‰‹å¯«è¾¨è­˜</li>
            <li>è¾¨è­˜å‡ºçš„å­—æ±ºå®šæ”»æ“ŠåŠ›èˆ‡äº”è¡Œå±¬æ€§</li>
            <li>ç©å®¶æ”»æ“Šå®Œå¾Œï¼ŒNPC æ‰æœƒåæ“Š</li>
          </ul>
          <p>2. æ”»æ“ŠåŠ›è¨ˆç®—ï¼š</p>
          <ul>
            <li><strong>æ”»æ“ŠåŠ› = ç­†ç•«æ•¸ Ã— äº”è¡Œç›¸å‰‹å€ç‡</strong></li>
            <li>åªçœ‹ç­†ç•«æ•¸ï¼Œä¸çœ‹å¸¥åº¦ã€ä¸çœ‹è§’è‰²è¨­å®š</li>
          </ul>
          <p>3. äº”è¡Œç›¸å‰‹ï¼ˆæœ‰å‰‹åˆ°æ‰ 1.2 å€ï¼Œå…¶ä»– 1.0 å€ï¼‰ï¼š</p>
          <ul>
            <li>é‡‘å‰‹æœ¨ã€æœ¨å‰‹åœŸã€åœŸå‰‹æ°´ã€æ°´å‰‹ç«ã€ç«å‰‹é‡‘</li>
          </ul>
          <p>4. è¾¨è­˜ä¸åˆ°æœ‰æ•ˆä¸­æ–‡å­— â†’ æœ¬å›åˆç©å®¶æ”»æ“Šå¤±æ•—ï¼Œä»æœƒè¢« NPC æ‰“ã€‚</p>
          <p>
            <span class="badge">å»ºè­°æ¸¬è©¦å­—</span>
            ç«ã€ç‚ã€æ°´ã€æ²³ã€æœ¨ã€æ—ã€æ£®ã€è‰ã€èŠ±ã€é‡‘ã€é‹¼ã€åœŸã€å²©â€¦
          </p>
        </div>
        <div class="log" id="log"></div>
        <div class="footer-hint">
          æœ¬ç‰ˆå®Œå…¨ä½¿ç”¨æœ¬åœ°æ‰‹å¯«è¾¨è­˜ï¼ˆHanziLookupJSï¼‰ï¼Œä¸ç”¨ Cloud Visionã€ä¸éœ€è¼¸å…¥å­—ï¼Œä¹Ÿæ²’æœ‰ API é‡‘é¡å•é¡Œã€‚<br>
          å¾ŒçºŒå¯ä»¥å†ä¸²åŠ‡æƒ…ã€ç­‰ç´šã€è£å‚™ã€æ•™å­¸é—œå¡ç­‰ç³»çµ±ã€‚
        </div>
      </div>
    </div>
  </div>

  <script>
    /*********************************
     * 1. HanziLookupJS åˆå§‹åŒ–
     *********************************/
    let hanziReady = false;
    let hanziMatcher = null;

    function initHanziLookup() {
      // ä½¿ç”¨ mmah è³‡æ–™æª”ï¼ˆMake Me a Hanziï¼‰
      HanziLookup.init("mmah", "mmah.json", function (success) {
        if (!success) {
          statusText.textContent = "âŒ æ‰‹å¯«è¾¨è­˜å­—åº«è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ mmah.json è·¯å¾‘ã€‚";
          return;
        }
        hanziMatcher = new HanziLookup.Matcher("mmah");
        hanziReady = true;
        logLine("ğŸ“š æ‰‹å¯«è¾¨è­˜å­—åº«è¼‰å…¥å®Œæˆï¼Œå¯ä»¥é–‹å§‹æˆ°é¬¥ã€‚");
      });
    }

    /*********************************
     * 2. å­—åº«èˆ‡äº”è¡Œè¨­å®šï¼ˆåªçœ‹ç­†ç•«æ•¸ï¼‰
     *********************************/
    const CHAR_DATA = {
      // ç«ç³»
      "ç«": { strokes: 4, element: "fire" },
      "ç‚": { strokes: 8, element: "fire" },
      "ç„°": { strokes: 11, element: "fire" },

      // æ°´ç³»
      "æ°´": { strokes: 4, element: "water" },
      "æ²³": { strokes: 8, element: "water" },
      "æ¹–": { strokes: 12, element: "water" },
      "å†°": { strokes: 6, element: "water" },

      // æœ¨ç³»
      "æœ¨": { strokes: 4, element: "wood" },
      "æ—": { strokes: 8, element: "wood" },
      "æ£®": { strokes: 12, element: "wood" },
      "è‰": { strokes: 9, element: "wood" },
      "èŠ±": { strokes: 7, element: "wood" },

      // é‡‘ç³»
      "é‡‘": { strokes: 8, element: "metal" },
      "é‡": { strokes: 10, element: "metal" },
      "é‹¼": { strokes: 16, element: "metal" },

      // åœŸç³»
      "åœŸ": { strokes: 3, element: "earth" },
      "åœ°": { strokes: 6, element: "earth" },
      "å²©": { strokes: 8, element: "earth" }
    };

    const ELEMENT_NAMES = {
      metal: "é‡‘",
      wood: "æœ¨",
      water: "æ°´",
      fire: "ç«",
      earth: "åœŸ",
      none: "ç„¡å±¬æ€§"
    };

    function elementToText(elem) {
      return ELEMENT_NAMES[elem] || "ç„¡å±¬æ€§";
    }

    // äº”è¡Œç›¸å‰‹å€ç‡ï¼šåªæœ‰ã€Œå‰‹åˆ°ã€1.2ï¼Œå…¶é¤˜ 1.0
    function getElementMultiplier(attElem, defElem) {
      if (!attElem || !defElem) return 1.0;
      if (attElem === "metal" && defElem === "wood") return 1.2;
      if (attElem === "wood"  && defElem === "earth") return 1.2;
      if (attElem === "earth" && defElem === "water") return 1.2;
      if (attElem === "water" && defElem === "fire") return 1.2;
      if (attElem === "fire"  && defElem === "metal") return 1.2;
      return 1.0;
    }

    function getCharInfo(ch) {
      if (CHAR_DATA[ch]) {
        return CHAR_DATA[ch];
      }
      // ä¸åœ¨å­—åº«ï¼šç•¶ 5 ç•«ã€ç„¡å±¬æ€§ï¼ˆä¹‹å¾Œå¯æ”¹æˆæŸ¥æ•™è‚²éƒ¨è³‡æ–™ï¼‰
      return { strokes: 5, element: "none" };
    }

    /*********************************
     * 3. æˆ°é¬¥ç‹€æ…‹èˆ‡é‚è¼¯
     *********************************/
    const MAX_HP = 100;
    let playerHp = MAX_HP;
    let enemyHp  = MAX_HP;
    let isBattleOver = false;

    // å›åˆç‹€æ…‹ï¼šidle / writing / resolving
    let turnState = "idle";
    const TURN_TIME_LIMIT = 5; // ç§’
    let timeLeft = TURN_TIME_LIMIT;
    let timerId = null;

    const playerHpText = document.getElementById("playerHpText");
    const enemyHpText  = document.getElementById("enemyHpText");
    const playerHpBar  = document.getElementById("playerHpBar");
    const enemyHpBar   = document.getElementById("enemyHpBar");
    const logEl        = document.getElementById("log");
    const startTurnBtn = document.getElementById("startTurnBtn");
    const restartBtn   = document.getElementById("restartBtn");
    const clearCanvasBtn = document.getElementById("clearCanvasBtn");
    const statusText   = document.getElementById("statusText");
    const timerText    = document.getElementById("timerText");

    function updateHpUI() {
      playerHpText.textContent = `${playerHp} / ${MAX_HP}`;
      enemyHpText.textContent  = `${enemyHp} / ${MAX_HP}`;
      playerHpBar.style.width = Math.max(0, (playerHp / MAX_HP) * 100) + "%";
      enemyHpBar.style.width  = Math.max(0, (enemyHp / MAX_HP) * 100) + "%";
    }

    function logLine(text) {
      const div = document.createElement("div");
      div.className = "log-line";
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function randomEnemyChar() {
      const keys = Object.keys(CHAR_DATA);
      const idx = Math.floor(Math.random() * keys.length);
      return keys[idx];
    }

    function calcDamage(attChar, defChar) {
      const attInfo = getCharInfo(attChar);
      const defInfo = getCharInfo(defChar);
      const baseATK = attInfo.strokes; // åªçœ‹ç­†ç•«æ•¸
      const multiplier = getElementMultiplier(attInfo.element, defInfo.element);
      const damage = Math.round(baseATK * multiplier);
      return Math.max(damage, 1);
    }

    function endBattle(winner) {
      isBattleOver = true;
      turnState = "idle";
      stopTurnTimer();
      startTurnBtn.disabled = true;

      let text = "";
      if (winner === "player") {
        text = "âœ… æˆ°é¬¥çµæŸï¼šç©å®¶å‹åˆ©ï¼";
      } else if (winner === "enemy") {
        text = "âŒ æˆ°é¬¥çµæŸï¼šç©å®¶è¢«æ‰“å€’äº†â€¦";
      } else {
        text = "âš– æˆ°é¬¥çµæŸï¼šå¹³æ‰‹ã€‚";
      }
      logLine(text);
      statusText.textContent = text;
      timerText.textContent = "";
    }

    function restartBattle() {
      playerHp = MAX_HP;
      enemyHp  = MAX_HP;
      isBattleOver = false;
      turnState = "idle";
      stopTurnTimer();
      timerText.textContent = "";
      statusText.textContent = "";
      logEl.innerHTML = "";
      updateHpUI();
      clearCanvas();
      startTurnBtn.disabled = false;
      logLine("âœ¨ æˆ°é¬¥é–‹å§‹ï¼ç­‰å­—åº«è¼‰å…¥å®Œæˆå¾Œï¼ŒæŒ‰ã€Œé–‹å§‹å›åˆã€åœ¨ 5 ç§’å…§å¯«å‡ºä¸€å€‹å­—ã€‚");
    }

    function startTurn() {
      if (isBattleOver) return;
      if (!hanziReady) {
        statusText.textContent = "è«‹ç­‰å­—åº«è¼‰å…¥å®Œæˆå†é–‹å§‹ï¼ˆä¸‹æ–¹ log æœƒé¡¯ç¤ºå®Œæˆè¨Šæ¯ï¼‰ã€‚";
        return;
      }
      if (turnState !== "idle") return;

      turnState = "writing";
      timeLeft = TURN_TIME_LIMIT;
      statusText.textContent = "è«‹åœ¨ 5 ç§’å…§å¯«ä¸€å€‹å­—ï¼æ™‚é–“åˆ°æœƒè‡ªå‹•é€å‡ºã€‚";
      timerText.textContent = `å‰©é¤˜æ™‚é–“ï¼š${timeLeft} ç§’`;
      clearCanvas();
      canDraw = true;

      startTurnBtn.disabled = true; // é¿å…é€£æŒ‰
      stopTurnTimer();
      timerId = setInterval(() => {
        timeLeft -= 1;
        if (timeLeft <= 0) {
          timerText.textContent = `æ™‚é–“åˆ°ï¼æ­£åœ¨è¾¨è­˜â€¦`;
          stopTurnTimer();
          canDraw = false;
          resolveTurnAfterTimeout();
        } else {
          timerText.textContent = `å‰©é¤˜æ™‚é–“ï¼š${timeLeft} ç§’`;
        }
      }, 1000);
    }

    function stopTurnTimer() {
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    async function resolveTurnAfterTimeout() {
      if (isBattleOver) return;
      turnState = "resolving";
      try {
        statusText.textContent = "âŒ› æ­£åœ¨é€²è¡Œæ‰‹å¯«è¾¨è­˜â€¦";

        const playerChar = await recognizeCharacterFromStrokes();
        const enemyChar = randomEnemyChar();
        const pInfo = getCharInfo(playerChar);
        const eInfo = getCharInfo(enemyChar);

        // ç©å®¶æ”»æ“Š
        const damageToEnemy = calcDamage(playerChar, enemyChar);
        enemyHp = Math.max(0, enemyHp - damageToEnemy);
        logLine(
          `ğŸ§‘ ç©å®¶ç”¨ã€Œ${playerChar}ã€ï¼ˆ${pInfo.strokes} ç•«ï¼Œ${elementToText(pInfo.element)}ï¼‰æ”»æ“Š ` +
          `ğŸ‘¾ NPC çš„ã€Œ${enemyChar}ã€ï¼ˆ${eInfo.strokes} ç•«ï¼Œ${elementToText(eInfo.element)}ï¼‰ï¼Œé€ æˆ ${damageToEnemy} å‚·å®³ï¼`
        );
        updateHpUI();

        if (enemyHp <= 0) {
          endBattle("player");
          return;
        }

        // NPC åæ“Š
        const damageToPlayer = calcDamage(enemyChar, playerChar);
        playerHp = Math.max(0, playerHp - damageToPlayer);
        logLine(`ğŸ‘¾ NPC ç”¨ã€Œ${enemyChar}ã€åæ“Šï¼Œå°ç©å®¶é€ æˆ ${damageToPlayer} å‚·å®³ï¼`);
        updateHpUI();

        if (playerHp <= 0) {
          endBattle("enemy");
          return;
        }

        statusText.textContent = `æœ¬å›åˆçµæŸï¼šä½ ç”¨ã€Œ${playerChar}ã€ï¼ŒNPC ç”¨ã€Œ${enemyChar}ã€ã€‚`;
      } catch (err) {
        console.error(err);
        // è¾¨è­˜å¤±æ•—ï¼šç©å®¶æ”»æ“Šè½ç©ºï¼ŒNPC ä»ç„¶æ”»æ“Š
        const enemyChar = randomEnemyChar();
        const eInfo = getCharInfo(enemyChar);
        // ä»¥ã€Œç„¡å±¬æ€§ 5 ç•«ã€ç•¶ä½œç©å®¶é˜²å®ˆ
        const damageToPlayer = calcDamage(enemyChar, "");
        playerHp = Math.max(0, playerHp - damageToPlayer);
        logLine("âš ï¸ æ‰‹å¯«è¾¨è­˜å¤±æ•—ï¼Œç©å®¶æœ¬å›åˆæ”»æ“Šè½ç©ºã€‚");
        logLine(
          `ğŸ‘¾ NPC æŠ“æº–æ©Ÿæœƒï¼Œç”¨ã€Œ${enemyChar}ã€ï¼ˆ${eInfo.strokes} ç•«ï¼Œ${elementToText(eInfo.element)}ï¼‰æ”»æ“Šç©å®¶ï¼Œé€ æˆ ${damageToPlayer} å‚·å®³ï¼`
        );
        updateHpUI();

        if (playerHp <= 0) {
          endBattle("enemy");
          return;
        }

        statusText.textContent = "æœ¬å›åˆçµæŸï¼šè¾¨è­˜å¤±æ•—ï¼Œä¸‹å›åˆè«‹å¯«å¾—æ›´æ¸…æ¥šä¸€é»ã€‚";
      } finally {
        if (!isBattleOver) {
          turnState = "idle";
          startTurnBtn.disabled = false;
          timerText.textContent = "";
        }
      }
    }

    /*********************************
     * 4. ä½¿ç”¨ HanziLookupJS åšã€ŒçœŸæ‰‹å¯«ã€è¾¨è­˜
     *********************************/
    async function recognizeCharacterFromStrokes() {
      if (!hanziReady || !hanziMatcher) {
        throw new Error("å­—åº«å°šæœªè¼‰å…¥å®Œæˆ");
      }
      if (!strokes.length) {
        throw new Error("ç•«å¸ƒä¸Šæ²’æœ‰ä»»ä½•ç­†ç•«");
      }

      // HanziLookup.AnalyzedCharacter éœ€è¦ã€Œé™£åˆ—çš„ç­†ç•«ã€ï¼Œæ¯ç­†ç•«æ˜¯ä¸€ä¸² [x, y] é»
      const analyzedChar = new HanziLookup.AnalyzedCharacter(strokes);

      return new Promise((resolve, reject) => {
        hanziMatcher.match(analyzedChar, 1, function (matches) {
          if (!matches || matches.length === 0) {
            reject(new Error("æ²’æœ‰å€™é¸å­—"));
            return;
          }
          const best = matches[0];
          if (!best.character) {
            reject(new Error("è¾¨è­˜çµæœç„¡æ•ˆ"));
            return;
          }
          resolve(best.character);
        });
      });
    }

    /*********************************
     * 5. ç•«å¸ƒï¼ˆæ‰‹å¯«å€ï¼‰ï¼‹ç­†ç•«ç´€éŒ„
     *********************************/
    const canvas = document.getElementById("drawCanvas");
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let lastX = 0;
    let lastY = 0;
    let canDraw = true;

    // strokes = [ stroke1, stroke2, ... ]
    // stroke = [ [x1, y1], [x2, y2], ... ]
    let strokes = [];

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width  = rect.width * ratio;
      canvas.height = rect.height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      clearCanvas();
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 4;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "#000000";
      strokes = [];
    }

    function getPos(e) {
      if (e.touches && e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        return {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
      } else {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }
    }

    function startDraw(e) {
      if (!canDraw || turnState !== "writing") return;
      e.preventDefault();
      drawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;

      // æ–°çš„ä¸€ç­†ç•«
      const stroke = [];
      stroke.push([pos.x, pos.y]);
      strokes.push(stroke);
    }

    function moveDraw(e) {
      if (!drawing || !canDraw || turnState !== "writing") return;
      e.preventDefault();
      const pos = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x;
      lastY = pos.y;

      // åœ¨ç•¶å‰ stroke åŠ å…¥æ–°é»
      if (strokes.length > 0) {
        const currentStroke = strokes[strokes.length - 1];
        currentStroke.push([pos.x, pos.y]);
      }
    }

    function endDraw(e) {
      if (!drawing) return;
      e.preventDefault();
      drawing = false;
    }

    canvas.addEventListener("mousedown", startDraw);
    canvas.addEventListener("mousemove", moveDraw);
    canvas.addEventListener("mouseup", endDraw);
    canvas.addEventListener("mouseleave", endDraw);

    canvas.addEventListener("touchstart", startDraw, { passive: false });
    canvas.addEventListener("touchmove",  moveDraw,   { passive: false });
    canvas.addEventListener("touchend",   endDraw,    { passive: false });
    canvas.addEventListener("touchcancel",endDraw,    { passive: false });

    window.addEventListener("resize", resizeCanvas);

    /*********************************
     * 6. äº‹ä»¶ç¶å®šèˆ‡åˆå§‹åŒ–
     *********************************/
    startTurnBtn.addEventListener("click", startTurn);
    restartBtn.addEventListener("click", restartBattle);
    clearCanvasBtn.addEventListener("click", () => {
      if (turnState === "idle" || turnState === "writing") {
        clearCanvas();
      }
    });

    // åˆå§‹åŒ–
    resizeCanvas();
    restartBattle();
    initHanziLookup();
  </script>
</body>
</html>
